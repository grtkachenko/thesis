%-*-coding: utf-8-*-
\chapter{Решение задачи поиска кратчайшего расстояния от фиксированной вершины до всех остальных}
\label{chapSVD}

В данной главе описаны алгоритмы по решению классической задачи на графах --- поиску кратчайших расстояний от одной вершины до всех остальных. В первой части главы представлен обзор существующих решений задачи. В второй части предложены разработанные мною параллельные модификации алгоритма Беллмана-Форда. В третьей части реализованные алгоритмы сравниваются и выявляются области их применимости.

\FloatBarrier
\section{Обзор существующих решений}
\subsection{Алгоритм Дейкстры}

Одним из наиболее заметных алгоритмов для решения данной задачи является алгоритм Дейкстры. Придуманный еще в 1959 году Эдсгером Вибе Дейкстрой он сохраняет свою актуальность и по сей день. Основная идея состоит в последовательном пополнении множества вершин, расстояние для которых уже корректно посчитано. При этом на каждом шаге выбирается вершина, которая находится ближе остальных к уже посчитанному множеству. 

Существует множество модификации алгоритма основанных на различных структурах данных для выбора вершины с минимальный расстоянием на каждом из шагов алгоритма. В зависимости от этого алгоритм может работать $O(V^2+E)$, $O(E \log V)$ или $O(V \log V+E)$. 

Основная проблема алгоритма состоит в том, что он работает только на графах с неотрицательным весом ребер. С этой проблемой справляется алгоритм Беллмана-Форда. 


\FloatBarrier
\subsection{Алгоритм Беллмана-Форда}

Классический алгоритм Беллмана-Форда работает на графах с произвольным весом ребер, однако имеет заметно худшую асимптотику по сравнению с алгоритмом Дейсктры --- $O(VE)$. 

В основе алгоритма лежит идея динамического программирования. После $k$ итерации алгоритма утверждается, что будут корректно посчитаны и обработаны значения веса путей длиной не более $k$. И после $V$ итерации расстояние до каждой из вершин посчитано корректно. Ниже приведен каноничный псевдокод алгоритма. 

\FloatBarrier
\begin{algorithm}
\caption{Классический алгоритм Беллмана-Форда}\label{bf_classic_seq}
\begin{algorithmic}[1]
\Procedure{ClassicBellmanFord}{$G,start$}
\State {$dist \gets \left\{ {\infty ... \infty}\right\}$}
\State {$dist[start] \gets 0$}
 
\For{$i = 0$ to $|G.vertices| - 1 $}
	\For{$e \in G.edges $}
		\State $dist[e.to] \gets \min(dist[e.to], dist[e.from] + e.w)$
	\EndFor
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
Кроме того существует интересная модификация алгоритма, которая поддерживает на каждой итерации набор вершин, расстояние до которых изменилось на предыдущем шаге алгоритма. Из очевидных соображений мы имеем право рассматривать только эти и никакие другие вершины. Этот алгоритм на практике зачастую работает заметно быстрее, чем классическая версия. Однако в некоторых случаях он оказывается медленнее. Об этих особенностях подхода подробно описано в разделе, посвященному сравнению алгоритмов. Будем называть эту версию BFS-подобный Беллман-Форд (Алгоритм \ref{bf_bfs_seq}). 

\FloatBarrier
\begin{algorithm}
\caption{BFS-подобный Беллман-Форд}\label{bf_bfs_seq}
\begin{algorithmic}[1]
\Procedure{BFSBellmanFord}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
\State $CurrentVertexSet \gets \left\{ {start}\right\}$\Comment{Набор вершин, расстояние до которых обновилось} 
\State $NextVertexSet \gets \emptyset$ 
\State {$step \gets 0$ }
\While {$step < |G.vertices|$ \algorithmicand \algorithmicnot $ CurrentVertexSet.empty()$}
	\State $step \gets step + 1$
	\State $NextVertexSet.clear()$
	
	\For{$v \in CurrentVertexSet$}
		\For{$e \in G.edgesFrom[v] $} \Comment{Исходящие ребра из текущей вершины} 
			\If {$dist[e.to] > dist[e.from] + e.w$} 
				\State $dist[e.to] \gets dist[e.from] + e.w$
				\State $NextVertexSet.insert(e.to)$								
			\EndIf
		\EndFor
	\EndFor
	
	\State $CurrentVertexSet \gets NextVertexSet$	
\EndWhile
\State \textbf{return} $dist$

\EndProcedure
\end{algorithmic}
\end{algorithm}

Также известны специализированные алгоритмы, такие как алгоритм A* и D*, которые оперирует большими специализированными графами и используют ряд эвристик для поиска расстояний. При этом в контексте наших исследований они затронуты не будут, а сосредоточимся мы именно на алгоритме Беллмана-Форда.


\FloatBarrier
\subsection{Обзор параллельных модификации Беллмана-Форда}

Большинство параллельных алгоритмов опираются на классическую реализацию алгоритма Беллмана-Форда и применяют различные методы для параллелизации внутреннго цикла релаксации ребер \cite{COHEN}\cite{GAURAV}. Кроме того, известны статьи, в которых описаны методы параллелизации BFS-подобной версии Беллмана-Форда \cite{LIGRA}. Мною предложенная BFS-подобная версия показала лучший результат, нежели существующий аналог. При этом для параллельных модификации классической версии были обозначены области применения и их преимущества и недостатки относительно BFS-подобной версии. Однако, в силу специфичности многих существующих решений и их зависимости от библиотек, на которых они основаны, мною предложенные параллельные версии классического Беллмана-Форда сравниваться с аналогами не будут. 


\FloatBarrier
\section{Параллельный алгоритм Беллмана-Форда}

В предыдущей главе были рассмотрены классические алгоритмы поиска кратчайших путей в графе, а также существующие параллельные модификации. В этой главе будут рассмотрены мною разработанные версии алгоритма Беллмана-Форда в контексте параллельных вычислений. Кроме того будем использовать в каждом из алгоритмов идею ранней остановки --- если на текущем шаге ни одно из значений массива расстояний не изменилось, то имеем право выйти из основного цикла. В последующих подразделах будет представлено несколько версий алгоритма, а также их последующее сравнение и рекомендации по использованию.  

\FloatBarrier
\subsection{Параллелизация по ребрам вершины}

Прежде чем приступить к описанию параллельной версий выполним небольшую модификацию алгоритма. Будем для каждой вершины перебирать не исходящие ребра, а входящие. Это ход даст нам одно важное преимущество в контексте параллельных алгоритмов --- значение кратчайшего расстояния до каждой вершины теперь может изменять лишь один поток, тогда как раньше могли несколько, что увеличивало потенциальные проблема с гонками за ресурс.

Первая версия алгоритма основана на параллельной обработке всех ребер, входящих в текущую вершины. Псевдокод, который уже использует идею из предыдущего абзаца, приведен ниже. Алгоритм, как и классическая версия, работает в худшем случае за $O(VE)$. 


\FloatBarrier
\begin{algorithm}
\caption{Параллельный Беллман-Форд по ребрам вершины}\label{bf_classic_par1}
\begin{algorithmic}[1]
\Procedure{BellmanFordPar1}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
 
\For{$i = 0$ to $|G.vertices| - 1 $}
	\State {$changed \gets $ \algorithmicfalse}
	\For{$v \in G.vertices $}
		\algrenewcommand\algorithmicfor{\textbf{parfor}}
		\State $minDist \gets dist[v]$

		\For{$e \in G.edgesTo[v] $} \Comment{Входящие ребра в текущую вершину} 
			\State $minDist \gets \min(minDist, dist[e.from] + e.w)$
		\EndFor	
					
		\If {$dist[v] > minDist$} 
			\State $dist[v] \gets minDist$ \Comment{Атомарно} 

			\State {$changed \gets $ \algorithmictrue}					
		\EndIf

		\algrenewcommand\algorithmicfor{\textbf{for}}

	\EndFor
	\If {\algorithmicnot $changed$} 
		\State \textbf{break}
	\EndIf

\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\subsection{Параллелизация по всем ребрам}
Идея второго алгоритма состоит в разбиений всего набора вершин на некоторые подмножества, каждое из которых будет обрабатываться отдельным процессором. При этом опять же, как и в предыдущем алгоритме, для каждой вершины будем рассматривать набор ребер, входящих в нее. 

Рассмотрим псеводкод алгоритма. Процесс поиска расстояний разбивается на два этапа. Рассмотрим каждый из этапов по отдельности.

На первом этапе мы строим разбиение всего множества вершин на подмножества, каждое из которых будет обрабатываться последовательно. Причем необходимо выполнить разбиение таким образом, чтобы суммарное количество входящих в вершины текущего подмножества ребер было не более $threshold$.  Это реализовано во-первых с помощью построение массива частичных сумм для входящих ребер --- это необходимо, чтобы мы могли получать за $O(1)$ количество входящих ребер на некотором отрезке вершин. Во-вторых разбиение строится за счет рекурсивной функции $BuildPlan$, которая строит хэш-таблицу, возвращающая по индексам концов отрезка его середину в смысле количества входящих ребер. Это можно добиться за счет запуска двоичного поиска на соответствующем отрезке массива частичных сумм. 

На втором этапе мы непосредственно вычисляем кратчайшие расстояния до вершин. Эта функция использует посчитанные раннее частичные суммы и полученную из функции $BuildPlan$ хэш-таблицу. Так как в этой функции мы использовали ту же константу $threshold$, что и на первом этапе алгоритма, то нам непосредственно в процессе вычисления не придется запускать двоичный поиск, а мы лишь будем пользоваться полученной хэш-таблицей для получение искомой середины отрезка. Таким образом, нам придется запустить процедуру с применением двоичных поисков лишь на первом этапе один раз, а далее мы за $O(1)$ на каждой итерации будем вычислять искомую середину отрезка. 

Алгоритм также как и предыдущая версия работает в худшем случае за $O(VE)$, однако он имеет значительно большую практическую пользу. Эта тема будут подробно рассмотрена позднее в подразделе «Сравнение алгоритмов». 
\FloatBarrier
\begin{algorithm}[H]
\caption{Параллельный Беллман-Форд по всем ребрам}\label{bf_classic_par2}
\begin{algorithmic}[1]
\Procedure{BellmanFordPar2}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
\State {$prefsum \gets $ prefix sum by vertices incoming degree} 
\State {$planMap \gets $ empty map}
\State \Call {BuildPlan}{$prefsum$, 0, |$G.vertices$|, planMap}

\For{$i = 0$ to $|G.vertices| $}	
	\If {\algorithmicnot \Call {ProcessLayer}{$G, dist, planMap, prefsum, 0, |G.vertices|$}} 
		\State \textbf{break}
	\EndIf
		
\EndFor
\State \textbf{return} $dist$
\EndProcedure

\State 
\Procedure{BuildPlan}{$prefsum, startV, endV, resultMap$}  
\State $edgesNumber \gets prefsum[endV] - prefsum[startV]$
\If {$edgesNumber < threshold$} 
	\State $midV \gets $ Бинарным поиском по массиву prefsum находим индекс вершины $midV$, что $prefsum[midV]-prefsum[startV] \approx prefsum[endV]-prefsum[midV]$
	\State $resultMap[startV][endV] \gets midV$ 
	\State \Call {BuildPlan}{$prefsum, startV, midV, resultMap$} 
	\State {\Call {BuildPlan}{$prefsum, midV, endV, resultMap$}} 
\EndIf

\State \textbf{return} $resultMap$
\EndProcedure

\State 
\Procedure{ProcessLayer}{$G, dist, planMap, prefsum, startV, endV$}  
\State $edgesNumber \gets prefsum[endV] - prefsum[startV]$
\If {$edgesNumber < threshold$} 
	\State {\textbf{return} {\Call {ProcessVerticesSequentially}{$G, dist, startV, endV$}}}
\Else	
	\State $midV \gets planMap[startV][endV]$ 
	\State {$changed \gets $ \algorithmicfalse}

	\State {$changed = changed $ \algorithmicor \Call {ProcessLayer}{$G, dist, planMap, prefsum, startV, midV$}}
	\State {$changed = changed $ \algorithmicor \Call {ProcessLayer}{$G, dist, planMap, prefsum, midV, endV$}}
	\State \textbf{return} $changed$
\EndIf

\EndProcedure

\State 
\Procedure{ProcessVerticesSequentially}{$G, dist, startV, endV$}  

\State {$changed \gets $ \algorithmicfalse}
\For{$v = startV$ to $endV - 1 $}
		\State $minDist \gets dist[v]$

		\For{$e \in G.edgesTo[v] $} \Comment{Входящие ребра в текущую вершину} 
			\State $minDist \gets \min(minDist, dist[e.from] + e.w)$
		\EndFor	
					
		\If {$dist[v] > minDist$} 
			\State $dist[v] \gets minDist$ \Comment{Атомарно} 

			\State {$changed \gets $ \algorithmictrue}					
		\EndIf
\EndFor
\State \textbf{return} $changed$

\EndProcedure

\end{algorithmic}
\end{algorithm}

\FloatBarrier
\subsection{Параллелизация BFS - версии}
Предыдущие две версии были основаны на параллелизации классической версии Беллмана-Форда. В основе следующего алгоритма лежит BFS-подобный Беллман-Форд (Алгоритм \ref{bf_bfs_seq}). В качестве основы для параллельной версии такого алгоритма был взят параллельный обход в ширину, предложенный Умутом Акаром и Майком Рэйни \cite{FRONTIERSEARCH}. 


Ключевым моментом в алгоритме является использованием структуры данных Frontier. Она подробно рассмотрена в статье Умута Акара и Майка Рэйни. Здесь же приведено краткое ее описание, основные принципы работы и интерфейс. Frontier представляет из себя некоторый набор ребер. При этом он поддерживает операций разделения множества пополам, слияния множеств, добавления ребер вершины и итерирования по ребрам. При этом  операций слияния и разбиения выполняются за время пропорциональное $O(\log n)$, добавление ребер вершины происходит за константу, а итерирование за константу для каждого ребра. Такая асимптотика достигается за счет лежащей в основе Bootstrapped Chunked Sequence \cite{CHUNKEDSEQ}, которая представляет из себя последовательность, где каждому элементу сопоставляется его вес. И операций слияния и разбиения выполняются в соответсвии с этими весами и выполняются за $O(\log n)$. Более подробное описание Bootstrapped Chunked Sequence приведено в указанной раннее статье. 

Кроме того, в алгоритме используются важная возможность библиотеки для параллельных вычислений PASL \cite{PASL} (является альтернативой известного решения Cilk \cite{CILK}) --- взаимодействие между несколькими потоками. А именно каждый из потоков может понимать нуждаются ли в «помощи» другие потоки. И в случае положительного ответа он может «поделиться» данными для вычислений. 

Таким образом, псевдокод алгоритма выглядит следующим образом.

\FloatBarrier
\begin{algorithm}[H]
\caption{Параллельный BFS-подобный Беллман-Форд}\label{bf_bfs_par}
\begin{algorithmic}[1]
\Procedure{BellmanFordPar3}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $layerForVertex\gets \left\{ {-1 ... -1}\right\}$ \Comment{Номер последнего уровня, в котором посетили вершину} 
\State $dist[start] \gets 0$
\State $layerForVertex[start] \gets 0$
\State {$Frontier \gets \left\{ {G.edgesFrom(start)}\right\}$}\Comment{Исходящие ребра текущего множества } 

\For{$layer = 1$ to $|G.vertices| $}	
	\State $NextFrontier \gets \emptyset$

	\State {$Frontier \gets $  {\Call {HandleFrontier}{$Frontier, NextFrontier, layer, dists, layerForVertex$}}} 
	
	\If { $Frontier.empty()$} 
		\State \textbf{break}						
	\EndIf
		
		
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\State

\Procedure{HandleFrontier}{$CurFrontier, NextFrontier, layer, dists, layerForVertex$}
\While {\algorithmicnot $CurFrontier.empty()$}
	\If {$hasIncomingQuery()$}
		\If {$CurFrontier.nbEdges() \leq cutoff$}
			\State $rejectQuery()$			
		\Else		
			\State $NewCurFrontier \gets \emptyset$
			\State $NewNextFrontier \gets \emptyset$
			\State $CurFrontier.split(NewCurFrontier)$
			\State \begin{varwidth}[t]{\linewidth}fork2(\par
        \hskip\algorithmicindent {\Call {HandleFrontier}{$CurFrontier, NextFrontier, layer, dists, layerForVertex$}},\par
        \hskip\algorithmicindent {\Call {HandleFrontier}{$NewCurFrontier, NewNextFrontier, layer, dists, layerForVertex$}});
      \end{varwidth}
 			\State $NextFrontier.split(NewNextFrontier)$

		\EndIf
		
	\EndIf
	\State Frontier.iterNumber(pollingCutoff, updateFunction(from, to, weight, layer, dists, layerForVertex))
\EndWhile
\EndProcedure
\State
\Procedure{UpdateFunction}{$from, to, weight, layer, dists, layerForVertex, NextFrontier$}
\If {{\Call {TryToUpdateDistance}{$to, dists[from] + weight, dists$}}} 

	\If {{\Call {TryToSetVisited}{$to, layer, layerForVertex$}}} 
		\State $NextFrontier.pushEdgesOf(to)$
	\EndIf
	
\EndIf
\EndProcedure
\State
\Procedure{TryToSetVisited}{$vertex, layer, layerForVertex$}
\If {\algorithmicnot $layerForVertex[vertex] = layer$} 
	\State \textbf{return} {$cas(layerForVertex[vertex], layerForVertex[vertex], layer)$ }  
\EndIf
\State \textbf{return} {\algorithmicfalse}  
\EndProcedure
\State
\Procedure{TryToUpdateDistance}{$vertex, candidate, dists$}
\State \textbf{return} {$writeMin(dists[vertex], candidate)$} \Comment Атомарный минимум 
\EndProcedure

\end{algorithmic}
\end{algorithm}

В основе главной функции алгоритма $HandleFrontier$ лежит следующая идея. В процессе обработки текущего $CurFrontier$ мы во-первых узнаем нуждается ли другой процессор в данных для вычисления. Если да, то делимся в случае достаточного количества ребер. Иначе обрабатываем $pollingCutoff$ ребер и запускаем процесс снова. Обратим внимание, что в нем использованы упомянутые ранее возможности библиотеки PASL --- функции $hasIncomingQuery$ и $rejectQuery$. 

\FloatBarrier
\subsection{Сравнение подходов}
Несмотря на то, что все три алгоритма в худшем случае имеют одну асимптотику  $O(VE)$, каждый из вышеизложенных подходов имеет свои особенности, что позволяет каждому из них конкурировать друг с другом на некоторых типах графов. Рассмотрим эти особенности.

С первого взгляда может показаться, что Алгоритм \ref{bf_classic_par1} имеет лишь одни недостатки --- он наименьшим образом по сравнению с последующими задействует все процессоры и при этом асимптотически равен остальным двум. Однако рассмотрим внимательнее каноничный алгоритм Беллмана-Форда и запустим его на плотном графе, где для каждого ребра верно, что индекс вершины источника меньше индекса вершины назначения (будем называть такое ребро лексикографически отсортированным). В этом случае каноничной версии достаточно будет сделать лишь две итерации внешнего цикла, поскольку на каждой итераций внутреннего цикла значение расстояния для текущей вершины будет корректно посчитано (очевидно доказывается по принципу математической индукции). Иными словами, в этом случае алгоритм работает за $O(V + E)$. Так как количество итерации третьего алгоритма в подобных графах может быть значительным и размер текущей очереди может быть большим, а второму же алгоритму на таких графах хорошая способность параллелиться будет только вредить --- она будет заметно увеличивать число итераций внешнего цикла, то в таких случаях последние два алгоритма работают хуже первого.   

Но, очевидно, что в большинстве случаев последние два алгоритма будут показывать лучшие результаты. Сравним эти два подхода. Алгоритм, основанный на обходе в ширину, заметно сокращает количество вершин для обработки в пределах каждой итерации, что дает заметное преимущество на разреженных графах по сравнению с Алгоритмом \ref{bf_classic_par2}, где на каждом шаге обрабатываются все ребра. Однако на плотных графах количество таких вершин значительно, что негативно сказывается на производительностью алгоритма в силу множественных и трудоемких операций с памятью. То есть такой подход показывает себя не с лучшей стороны в подобных графах. Кроме того, в случая с графами с циклами отрицательного веса даже в случае разреженного графа размер текущего Frontier может быть велик. Это достигается в том случае, если количество вершин, из которых достижим цикл отрицательного веса велико. Однако провести такой анализ графа в общем случае не является простой задачей, то будем рекомендовать к использованию Алгоритм \ref{bf_classic_par2} при наличии в графе ребер отрицательного веса.

\FloatBarrier
\subsection{Тестирование}

Для подтверждения вышеприведенных рассуждений все вышеизложенные подходы были реализованы на основе уже раннее упомянутой библиотеки для параллельных вычислений PASL. В качестве языка программирования использовался C++. Тестирование производилось на ряде графов на 40-ядерной машине Intel с поддержкой hyper-threading \cite{HYPERTHREADING} с доступной оперативной памятью 256GB. 

Алгоритмы тестировались на различных графовых структурах, которые перечислены в Таблице \ref{bf_algo_comparison}. 
\FloatBarrier
\begin{table}[H]
\centering
\caption{Описание входных графов}

\begin{tabular}{c | c | c | l}  
\multicolumn{4}{l}{\footnotesize \textit{fraction} - Доля лексикографически отсортированных ребер (ребра вида $V_i \rightarrow V_{i+j}$) }\\
\hline
Название & Вершины & Ребра & Описание\\
\hline\hline
Complete TS & 7071 & 24995985 & Полный граф с fraction = 1 (TopSorted)\\  
Complete + & 3162 & 9995082 & Полный граф с положительным весом ребер \\  
Complete - & 3162 & 9995082 & Полный граф с случайным весом ребер \\  
BalancedTree F & 8388607 & 8388608 & Сбалансирование дерево с fraction = F \\  
SquareGrid + & 2499561 & 4999122 & Квадратная решетка с положительными ребрами \\  
SquareGrid - & 2499561 & 4999122 & Квадратная решетка с случайными ребрами \\  
RandomSparse 0.5+ & 2500000 & 25000000 & \pbox{9cm}{Случайный разреженный граф с положительными ребрами и fraction = 0.5\\}  \\  
RandomSparse 0.5- & 2500000 & 25000000 & \pbox{9cm}{Случайный разреженный граф с любыми ребрами и fraction = 0.5\\}  \\  
RandomSparse 0.96+ & 2500000 & 25000000 & \pbox{9cm}{Cлучайный разреженный граф с положительными ребрами и fraction = 0.96\\} \\  
RandomDense 0.5+ & 5000 & 25000000 & \pbox{9cm}{Случайный плотный граф с положительными ребрами и fraction = 0.5\\}  \\  
RandomDense 0.5- & 5000 & 25000000 & \pbox{9cm}{Случайный плотный граф с любыми ребрами и fraction = 0.5\\}  \\  
RandomDense 0.96+ & 5000 & 25000000 & \pbox{9cm}{Случайный плотный граф с положительными ребрами и fraction = 0.96\\}  \\  
\hline

\end{tabular}

\label{bf_algo_comparison}
\end{table}
\FloatBarrier
Результаты запуска каждой версии алгоритма на описанных графах представлены в таблице \ref{graph_description}.
\begin{table}[H]
\centering
\caption{Результаты измерений производительности}
\begin{tabular}{l|ccc|cc|cc|ccc|ccc}  
\hline
Алгоритм & \multicolumn{3}{c}{Complete} & \multicolumn{2}{c}{BalancedTree} & \multicolumn{2}{c}{SquareGrid} & \multicolumn{3}{c}{RandomSparse} & \multicolumn{3}{c}{RandomDense}\\
& TS & + & - & 0.5 & 1 & + & +- & 0.5+  & 0.5- & 0.96+ & 0.5+ & 0.5- & 0.96+\\
\hline\hline
3 & 2.43 & 4.65 & nc & 116.31 & 9.04 & 5.49 & 13.40 & nc & nc & 24.35 & nc & nc & 5.01 \\  
4 & 5.17 & 0.18 & 10.84 & 3.59 & 3.08 & 5.92 & 7.10 & 2.77 & 14.68 & 2.42 & 0.48  & 6.38  & 0.46 \\
5 & 44.63 & 0.37 & 23.55 & 0.44 & 0.31 & 4.42 & 0.58 & 0.98 & 22.59 & 0.76  & 0.60  & 10.25 & 0.71 \\
Ligra & 49.13 & 0.30 & 26.11 & 0.55 & 0.50 & 8.15 & 1.21 & 0.59 & 25.19 & 0.48  & 1.12  & 14.15 & 1.20 \\
\hline
\end{tabular}

\label{graph_description}
\end{table}

\FloatBarrier
\section{Выводы}

Из таблиц видно, что наши ожидания относительно применимости конкретных подходов оправдались. Первый из алгоритмов работает лучше на узком спектре графов с высоким $fraction$ (доля лексикографически отсортированных ребер) и высокой средней степенью вершины, второй хорошо работает на плотных графах и графах с отрицательным весом ребер, третий же заметно лучше остальных на разреженных графах.

Кроме того, параллельный BFS-подобный Беллма-Форд оказался во многих ситуациях лучше аналога из библиотеки Ligra. Это прежде всего объясняется высокой производительностью работы структуры данных Frontier. Соответсвующее сравнение параллельных обходов в ширину, приведенное в работе Умута Акара \cite{FRONTIERSEARCH}, это еще раз подтверждает, поскольку эта модификация Беллмана-Форда во многом очень похожа на классический обход в ширину. 

Таким образом сделав простой анализ структуры графа мы сможем выбрать необходимый эффективный алгоритм для поиска кратчайшего пути. 
\FloatBarrier
