%-*-coding: utf-8-*-
\chapter{Решение задачи поиска кратчайшего расстояния от фиксированной вершины до всех остальных}
\label{chapSVD}

В данной главе описаны алгоритмы по решению классической задаче на графах - поиску кратчайших расстояний от одной вершины до всех остальных. В первой части главы представлен краткий обзор предметной области. Во второй параллельные модификации алгоритма Беллмана-Форда. 

\FloatBarrier
\section{Обзор существующих решений}
\subsection{Алгоритм Дейкстры}

Одним из наиболее заметных алгоритмов для решения данной задачи является алгоритм Дейкстры. Придуманный еще в 1959 году Эдсгером Вибе Дейкстрой он сохраняет свою актуальность и по сей день. Основная идея состоит в последовательном пополнении множества вершин, расстояние для которых уже корректно посчитано. При этом на каждом шаге выбирается вершина, которая находится ближе остальных к уже посчитанному множеству. 

Существует множество модификации алгоритма основанных на различных структурах данных для выбора вершины с минимальный расстоянием на каждом из шагов алгоритма. В зависимости от этого алгоритм может работать $O(V^2+E)$, $O(E \log V)$ или $O(V \log V+E)$. 

Основная проблема алгоритма состоит в том, что он работает только на графах с неотрицательным весом ребер. С этой проблемой справляется алгоритм Беллмана-Форда. 


\FloatBarrier
\subsection{Алгоритм Беллмана-Форда}

Классический алгоритм Беллмана-Форда работает на графах с произвольным весом ребер, однако имеет заметно худшую асимптотику по сравнению с алгоритмом Дейсктры - $O(VE)$. 

Основная идея алгоритма основана на идее динамического программирования. После $k$ итерации алгоритма утверждается, что будут корректно посчитаны и обработаны значения веса путей длиной не более $k$. И после $V$ итерации расстояние до каждой из вершин посчитано корректно. Ниже приведен каноничный псевдокод алгоритма. 

\FloatBarrier
\begin{algorithm}
\caption{Классический алгоритм Беллмана-Форда}\label{bf_classic_seq}
\begin{algorithmic}[1]
\Procedure{ClassicBellmanFord}{$G,start$}
\State {$dist \gets \left\{ {\infty ... \infty}\right\}$}
\State {$dist[start] \gets 0$}
 
\For{$i = 0$ to $|G.vertices| - 1 $}
	\For{$e \in G.edges $}
		\State $dist[e.to] \gets \min(dist[e.to], dist[e.from] + e.w)$
	\EndFor
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
Кроме того существует интересная модификация алгоритма, которая поддерживает на каждой итерации набор вершин, расстояние до которых изменились на предыдущем шаге алгоритма. Из очевидных соображений мы имеем право рассматривать только эти и никакие другие вершины. Этот алгоритм на практике зачастую работает заметно быстрее чем классическая версия в некоторых случаях, но об этом подробно будет описано позднее. Будем называть эту версию BFS-подобный Беллман-Форд. Ниже приведен псевдокод алгоритма 

\FloatBarrier
\begin{algorithm}
\caption{BFS-подобный Беллман-Форд}\label{bf_bfs_seq}
\begin{algorithmic}[1]
\Procedure{BFSBellmanFord}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
\State $CurrentVertexSet \gets \left\{ {start}\right\}$\Comment{Набор вершин, расстояние до которых обновилось} 
\State $NextVertexSet \gets \emptyset$ 
\State {$step \gets 0$ }
\While {$step < |G.vertices|$ \algorithmicand \algorithmicnot $ CurrentVertexSet.empty()$}
	\State $step \gets step + 1$
	\State $NextVertexSet.clear()$
	
	\For{$v \in CurrentVertexSet$}
		\For{$e \in G.edgesFrom[v] $} \Comment{Исходящие ребра из текущей вершины} 
			\If {$dist[e.to] > dist[e.from] + e.w$} 
				\State $dist[e.to] \gets dist[e.from] + e.w$
				\State $NextVertexSet.insert(e.to)$								
			\EndIf
		\EndFor
	\EndFor
	
	\State $CurrentVertexSet \gets NextVertexSet$	
\EndWhile
\State \textbf{return} $dist$

\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\subsection{Другие алгоритмы}

Также известны специализированные алгоритмы, такие как алгоритм A* и D*, которые оперирует большими специализированными графами и используют ряд эвристик для поиска расстояний. При этом в контексте наших исследований они затронуты не будут.

\FloatBarrier
\section{Параллельный алгоритм Беллмана-Форда}

В предыдущей главе были рассмотрены классические алгоритмы поиска кратчайших путей в графе. В этой главе будет рассмотрен алгоритм Беллмана-Форда в контексте параллельных вычислений. Кроме того будем использовать в каждом из алгоритмов идею ранней остановки - если на текущем шаге ни одно из значений массива расстояний не изменилось, то имеем право выйти из основного цикла. В последующих главах будет представлено несколько версий алгоритма, а также их последующее сравнение и рекомендации по использованию.  

\FloatBarrier
\subsection{Параллелизация по ребрам вершины}

Прежде чем приступить к описанию параллельной версий выполним небольшую модификацию алгоритма. Будем для каждой вершины перебирать не исходящие ребра, а входящие. Это ход даст нам одно важное преимущество в контексте параллельных алгоритмов - значение кратчайшего расстояние до каждой вершины теперь может изменять лишь один поток, тогда как раньше могли несколько, что увеличивало потенциальные проблема с гонками за ресурс.

Первая версия алгоритма основана на параллельной обработке всех ребер, исходящих из текущей вершины. Псевдокод, который уже использует идею из предыдущего абзаца, приведен ниже. 


\FloatBarrier
\begin{algorithm}
\caption{Параллельный Беллман-Форд по ребрам вершины}\label{bf_classic_par1}
\begin{algorithmic}[1]
\Procedure{BellmanFordPar1}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
 
\For{$i = 0$ to $|G.vertices| - 1 $}
	\State {$changed \gets $ \algorithmicfalse}
	\For{$v \in G.vertices $}
		\algrenewcommand\algorithmicfor{\textbf{parfor}}
		\State $minDist \gets dist[v]$

		\For{$e \in G.edgesTo[v] $} \Comment{Входящие ребра в текущую вершину} 
			\State $minDist \gets \min(minDist, dist[e.from] + e.w)$
		\EndFor	
					
		\If {$dist[v] > minDist$} 
			\State $dist[v] \gets minDist$ \Comment{Атомарно} 

			\State {$changed \gets $ \algorithmictrue}					
		\EndIf

		\algrenewcommand\algorithmicfor{\textbf{for}}

	\EndFor
	\If {\algorithmicnot $changed$} 
		\State \textbf{break}
	\EndIf

\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\subsection{Параллелизация по всем ребрам}
Идея второго алгоритма состоит в разбиений всего набора вершин на некоторые подмножества, каждое из которых будет обрабатываться отдельным процессором. При этом опять же, как и в предыдущем алгоритме, для каждой вершины будем рассматривать набор ребер, входящих в нее. 

\FloatBarrier
\begin{algorithm}[H]
\caption{Параллельный Беллман-Форд по всем ребрам}\label{bf_classic_par2}
\begin{algorithmic}[1]
\Procedure{BellmanFordPar2}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
\State {$prefsum \gets $ prefix sum by vertices incoming degree} 
\State {$planMap \gets $ empty map}
\State \Call {BuildPlan}{$prefsum$, 0, |$G.vertices$|, planMap}

\For{$i = 0$ to $|G.vertices| $}	
	\If {\algorithmicnot \Call {ProcessLayer}{$G, dist, planMap, prefsum, 0, |G.vertices|$}} 
		\State \textbf{break}
	\EndIf
		
\EndFor
\State \textbf{return} $dist$
\EndProcedure

\State 
\Procedure{BuildPlan}{$prefsum, startV, endV, resultMap$}  \Comment{Функция возвращают структуру (хэш-таблицу), которая по отрезку возвращает его середину}
\State $edgesNumber \gets prefsum[endV] - prefsum[startV]$
\If {$edgesNumber < threshold$} 
	\State $midV \gets $ Бинарным поиском по массиву prefsum находим индекс вершины $midV$, что $prefsum[midV]-prefsum[startV] \approx prefsum[endV]-prefsum[midV]$
	\State $resultMap[startV][endV] \gets midV$ 
	\State \Call {BuildPlan}{$prefsum, startV, midV, resultMap$} 
	\State {\Call {BuildPlan}{$prefsum, midV, endV, resultMap$}} 
\EndIf

\State \textbf{return} $resultMap$
\EndProcedure

\State 
\Procedure{ProcessLayer}{$G, dist, planMap, prefsum, startV, endV$}  
\State $edgesNumber \gets prefsum[endV] - prefsum[startV]$
\If {$edgesNumber < threshold$} 
	\State {\textbf{return} {\Call {ProcessVerticesSequentially}{$G, dist, startV, endV$}}}
\Else	
	\State $midV \gets planMap[startV][endV]$ 
	\State {$changed \gets $ \algorithmicfalse}

	\State {$changed = changed $ \algorithmicor \Call {ProcessLayer}{$G, dist, planMap, prefsum, startV, midV$}}
	\State {$changed = changed $ \algorithmicor \Call {ProcessLayer}{$G, dist, planMap, prefsum, midV, endV$}}
	\State \textbf{return} $changed$
\EndIf

\EndProcedure

\State 
\Procedure{ProcessVerticesSequentially}{$G, dist, startV, endV$}  

\State {$changed \gets $ \algorithmicfalse}
\For{$v = startV$ to $endV - 1 $}
		\State $minDist \gets dist[v]$

		\For{$e \in G.edgesTo[v] $} \Comment{Входящие ребра в текущую вершину} 
			\State $minDist \gets \min(minDist, dist[e.from] + e.w)$
		\EndFor	
					
		\If {$dist[v] > minDist$} 
			\State $dist[v] \gets minDist$ \Comment{Атомарно} 

			\State {$changed \gets $ \algorithmictrue}					
		\EndIf
\EndFor
\State \textbf{return} $changed$

\EndProcedure

\end{algorithmic}
\end{algorithm}

\FloatBarrier
\subsection{Параллелизация BFS - версии}
Предыдущие две версии были основаны на параллелизации классической версии Беллмана-Форда. В основе следующего алгоритма лежит идея обхода в ширину (Алгоритм 2). В качестве основы для параллельной версии такого алгоритма был взят параллельный обход в ширину, предложенный Умутом Акаром и Майком Рэйни. 


Ключевым моментом в алгоритме является использованием структуры данных Frontier. Она подробно рассмотрена в статье Умут Акара. Здесь же приведено краткое ее описание, основные принципы работы и интерфейс. Frontier представляет из себя некоторый набор ребер. При этом он поддерживает операций разделения множества пополам, слияния множеств, добавления ребер вершины и итерирования по ребрам. При этом  операций слияния и разбиения выполняются за время пропорциональное $O(\log n)$, добавление ребер вершины происходит за константу, а итерирование за константу для каждого ребра. Такая асимптотика достигается за счет лежащей в основе bootstrapped chunked sequence, которая представляет из себя последовательность, где каждому элементу сопоставляется его вес. И операций слияния и разбиения выполняются в соответсвии с этими весами и выполняются за $O(\log n)$. Более подробное описание bootstrapped chunked sequence приведено в статье. 

Кроме того, в алгоритме используются возможности библиотеки для параллельных вычислений PASL взаимодействия между несколькими потоками. А именно каждый из потоков может понимать нуждаются ли в "помощи" другие потоки. И в случае положительного ответа он может "поделиться" данными для вычислений. 

Таким образом, псевдокод алгоритма выглядит следующим образом

\FloatBarrier
\begin{algorithm}[H]
\caption{Параллельный BFS-подобный Беллман-Форд}\label{bf_bfs_par}
\begin{algorithmic}[1]
\Procedure{BellmanFordPar3}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $layerForVertex\gets \left\{ {-1 ... -1}\right\}$ \Comment{Номер последнего уровня, в котором посетили вершину} 
\State $dist[start] \gets 0$
\State $layerForVertex[start] \gets 0$
\State {$Frontier \gets \left\{ {G.edgesFrom(start)}\right\}$}\Comment{Исходящие ребра текущего множества } 

\For{$layer = 1$ to $|G.vertices| $}	
	\State $NextFrontier \gets \emptyset$

	\State {$Frontier \gets $  {\Call {HandleFrontier}{$Frontier, NextFrontier, layer, dists, layerForVertex$}}} 
	
	\If { $Frontier.empty()$} 
		\State \textbf{break}						
	\EndIf
		
		
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\State

\Procedure{HandleFrontier}{$CurFrontier, NextFrontier, layer, dists, layerForVertex$}
\While {\algorithmicnot $CurFrontier.empty()$}
	\If {$hasIncomingQuery()$}
		\If {$CurFrontier.nbEdges() \leq cutoff$}
			\State $rejectQuery()$			
		\Else		
			\State $NewCurFrontier \gets \emptyset$
			\State $NewNextFrontier \gets \emptyset$
			\State $CurFrontier.split(NewCurFrontier)$
			\State \begin{varwidth}[t]{\linewidth}fork2(\par
        \hskip\algorithmicindent {\Call {HandleFrontier}{$CurFrontier, NextFrontier, layer, dists, layerForVertex$}},\par
        \hskip\algorithmicindent {\Call {HandleFrontier}{$NewCurFrontier, NewNextFrontier, layer, dists, layerForVertex$}});
      \end{varwidth}
 			\State $NextFrontier.split(NewNextFrontier)$

		\EndIf
		
	\EndIf
	\State Frontier.iterNumber(pollingCutoff, updateFunction(from, to, weight, layer, dists, layerForVertex))
\EndWhile
\EndProcedure
\State
\Procedure{UpdateFunction}{$from, to, weight, layer, dists, layerForVertex, NextFrontier$}
\If {{\Call {TryToUpdateDistance}{$to, dists[from] + weight, dists$}}} 

	\If {{\Call {TryToSetVisited}{$to, layer, layerForVertex$}}} 
		\State $NextFrontier.pushEdgesOf(to)$
	\EndIf
	
\EndIf
\EndProcedure
\State
\Procedure{TryToSetVisited}{$vertex, layer, layerForVertex$}
\If {\algorithmicnot $layerForVertex[vertex] = layer$} 
	\State \textbf{return} {$cas(layerForVertex[vertex], layerForVertex[vertex], layer)$ }  
\EndIf
\State \textbf{return} {\algorithmicfalse}  
\EndProcedure
\State
\Procedure{TryToUpdateDistance}{$vertex, candidate, dists$}
\State \textbf{return} {$writeMin(dists[vertex], candidate)$} \Comment Атомарный минимум 
\EndProcedure

\end{algorithmic}
\end{algorithm}


\FloatBarrier
\subsection{Сравнение подходов}
Несмотря на то, что все три алгоритма в худшем случае имеют одну асимптотику  $O(VE)$, каждый из вышеизложенных подходов имеет свои особенности, что позволяет каждому из них конкурировать друг с другом на некоторых типах графов. Рассмотрим эти особенности.

С первого взгляда может показаться, что Алгоритм 3 имеет лишь одни недостатки - он имеет наименьшим образом по сравнению с последующими задействует все процессоры и при этом асимптотически равен остальным двум. Однако рассмотрим внимательнее каноничный аглоритм Беллмана-Форда и запустим его на плотном графе, где для каждого ребра верно, что индекс вершины источника меньше индекса вершины назначения. В этом случае каноничной версии достаточно будет сделать лишь две итерации внешнего цикла, поскольку на каждой итераций внутреннего цикла значение расстояния для текущей вершины будет корректно посчитано (очевидно доказывается по математической индукции). Иными словами, в этом случае алгоритм работает за $O(V + E)$. Так как количество итерации третьего алгоритма в подобных графах может быть значительным и размер текущей очереди может быть большим, а второму же алгоритму на таких графах неплохая способность параллелиться будет только вредить - она будет заметно увеличивать число итераций внешнего цикла, то в таких случаях последние два алгоритма работают хуже первого.   

Но очевидно, что в большинстве случаев последние два алгоритма будут показывать лучшие результаты. Сравним эти два подхода. Алгоритм, основанный на обходе в ширину, заметно сокращает количество вершин для обработки в пределах каждой итерации, что дает заметное преимущество на разреженных графах по сравнению с Алгоритмом 4, где на каждом шаге обрабатываются все ребра. Однако на плотных графах количество таких вершин значительно, что негативно сказывается на производительностью алгоритма в силу множественных и трудоемких операций с памятью. То есть такой подход показывает себя не с лучшей стороны в подобных графах.  

\FloatBarrier
\subsection{Тестирование}

Для подтверждения вышеприведенных замечаний все вышеизложенные подходы были реализованы на основе библиотеки для параллельных вычислений PASL. В качестве языка использовался C++. Тестирование производилось на ряде графов на машине 40-core Intel machine (with hyper-threading) with 4×2.4GHz Intel
10-core E7-8870 Xeon processors, a 1066MHz bus, and 256GB of
main memory. 

Алгоритмы тестировались на различных графовых структурах, которые перечислены в Таблице 1.1. 
\FloatBarrier
\begin{table}[H]
\centering
\begin{tabular}{c | c | c | l}  
Название & Вершины & Ребра & Описание\\
\hline\hline
Complete TS & 7071 & 24995985 & Полный граф с fraction = 1 (TopSorted)\\  
Complete + & 3162 & 9995082 & Полный граф с положительным весом ребер \\  
Complete - & 3162 & 9995082 & Полный граф с случайным весом ребер \\  
BalancedTree F & 8388607 & 8388608 & Сбалансирование дерево с fraction = F \\  
SquareGrid + & 2499561 & 4999122 & Квадратная решетка с положительными ребрами \\  
SquareGrid - & 2499561 & 4999122 & Квадратная решетка с случайными ребрами \\  
RandomSparse 0.5+ & 2500000 & 25000000 & \pbox{9cm}{Случайный разреженный граф с положительными ребрами и fraction = 0.5\\}  \\  
RandomSparse 0.5- & 2500000 & 25000000 & \pbox{9cm}{Случайный разреженный граф с любыми ребрами и fraction = 0.5\\}  \\  
RandomSparse 0.96+ & 2500000 & 25000000 & \pbox{9cm}{Cлучайный разреженный граф с положительными ребрами и fraction = 0.96\\} \\  
RandomDense 0.5+ & 5000 & 25000000 & \pbox{9cm}{Случайный плотный граф с положительными ребрами и fraction = 0.5\\}  \\  
RandomDense 0.5- & 5000 & 25000000 & \pbox{9cm}{Случайный плотный граф с любыми ребрами и fraction = 0.5\\}  \\  
RandomDense 0.96+ & 5000 & 25000000 & \pbox{9cm}{Случайный плотный граф с положительными ребрами и fraction = 0.96\\}  \\  
\hline
\multicolumn{4}{l}{\footnotesize \textit{fraction} - Доля лексикографически отсортированных ребер (ребра вида $V \rightarrow V+i$) }\\
\end{tabular}

\caption{Input graph description}
\label{bf_algo_comparison}
\end{table}
\FloatBarrier
\begin{table}[H]
\centering

\begin{tabular}{l|ccc|cc|cc|ccc|ccc}  
Algo №& \multicolumn{3}{c}{Complete} & \multicolumn{2}{c}{BalancedTree} & \multicolumn{2}{c}{SquareGrid} & \multicolumn{3}{c}{RandomSparse} & \multicolumn{3}{c}{RandomDense}\\
& TS & + & - & 0.5 & 1 & + & +- & 0.5+  & 0.5- & 0.96+ & 0.5+ & 0.5- & 0.96+\\
\hline\hline
3 & 2.43 & 4.65 & nc & 116.31 & 9.04 & 5.49 & 13.40 & nc & nc & 24.35 & nc & nc & 5.01 \\  
4 & 5.17 & 0.18 & 10.84 & 3.59 & 3.08 & 5.92 & 7.10 & 2.77 & 14.68 & 2.42 & 0.48  & 6.38  & 0.46 \\
5 & 44.63 & 0.37 & 23.55 & 0.44 & 0.31 & 4.42 & 0.58 & 0.98 & 22.59 & 0.76  & 0.60  & 10.25 & 0.71 \\
\hline
\end{tabular}

\caption{Bellman-Ford algorithms comparison}
\label{graph_description}
\end{table}

\FloatBarrier
\section{Выводы}

Из таблиц видно, что наши ожидания относительно применимости конкретных подходов оправдались. Первый из алгоритмов работает лучше на узком спектре графов с высоким $fraction$ и высокой средней степенью вершины, второй хорошо работает на плотных графах и графах с отрицательным весом ребер, третий же заметно лучше остальных на разреженных графах.

Таким образом сделав простой анализ структуры графа мы сможем выбрать необходимый алгоритм для поиска кратчайшего пути. 
\FloatBarrier
