%-*-coding: utf-8-*-
\chapter{Реализация и тестирование предложенных алгоритмов}

В данной главе разработанные подходы будет сравниваться с существующими решения и между собой. При этом для каждого алгоритма будет обозначена область его применимости. В первой части главы приведен анализ и тестирования параллельных алгоритмов Беллмана-Форда, во второй части --- алгоритмов для поиска кратчайших расстояний между каждой парой вершин. Все вышеизложенные подходы были реализованы на основе уже раннее упомянутой библиотеки для параллельных вычислений PASL. В качестве языка программирования использовался C++. Тестирование производилось на ряде графов на 40-ядерной машине Intel с поддержкой hyper-threading \cite{HYPERTHREADING} с доступной оперативной памятью 256GB. 

\FloatBarrier
\section{Параллельный алгоритм Беллмана-Форда}

\FloatBarrier
\subsection{Анализ}

Несмотря на то, что все три предложенных алгоритма в худшем случае имеют одну асимптотику  $O(VE)$, каждый из вышеизложенных подходов имеет свои особенности, что позволяет каждому из них конкурировать друг с другом на некоторых типах графов. Рассмотрим эти особенности.

С первого взгляда может показаться, что алгоритм \ref{bf_classic_par1} имеет лишь одни недостатки --- он наименьшим образом по сравнению с последующими задействует все процессоры и при этом асимптотически равен остальным двум. Однако рассмотрим внимательнее каноничный алгоритм Беллмана-Форда и запустим его на плотном графе, где для каждого ребра верно, что индекс вершины источника меньше индекса вершины назначения (будем называть такое ребро лексикографически отсортированным). В этом случае каноничной версии достаточно будет сделать лишь две итерации внешнего цикла, поскольку на каждой итерации внутреннего цикла значение расстояния для текущей вершины будет корректно посчитано (очевидно доказывается по принципу математической индукции). Иными словами, в этом случае алгоритм работает за $O(V + E)$. Так как количество итерации третьего алгоритма в подобных графах может быть значительным и размер текущей очереди может быть большим, а второму же алгоритму на таких графах хорошая способность параллелиться будет только вредить --- она будет заметно увеличивать число итераций внешнего цикла, то в таких случаях последние два алгоритма работают хуже первого.   

Но, очевидно, что в большинстве случаев последние два алгоритма будут показывать лучшие результаты. Сравним эти два подхода. Алгоритм, основанный на обходе в ширину, заметно сокращает количество вершин для обработки в пределах каждой итерации, что дает заметное преимущество на разреженных графах по сравнению с алгоритмом \ref{bf_classic_par2}, где на каждом шаге обрабатываются все ребра. Однако на плотных графах количество таких вершин значительно, что негативно сказывается на производительности алгоритма в силу множественных и трудоемких операций с памятью. То есть такой подход показывает себя не с лучшей стороны в подобных графах. Кроме того, в случае с графами с циклами отрицательного веса даже в случае разреженного графа размер текущего Frontier может быть велик. Это достигается в том случае, если количество вершин, из которых достижим цикл отрицательного веса велико. Однако провести такой анализ графа в общем случае не является простой задачей, то будем рекомендовать к использованию алгоритм \ref{bf_classic_par2} при наличии в графе ребер отрицательного веса.

\FloatBarrier
\subsection{Тестирование}



Алгоритмы тестировались на различных графовых структурах, которые перечислены в Таблице \ref{bf_algo_comparison}. 
\FloatBarrier
\begin{table}[H]
\centering
\caption{Описание входных графов}

\begin{tabular}{c | c | c | l}  
\multicolumn{4}{l}{\footnotesize \textit{fraction} - Доля лексикографически отсортированных ребер (ребра вида $V_i \rightarrow V_{i+j}$) }\\
\hline
Название & Вершины & Ребра & Описание\\
\hline\hline
Complete TS & 7071 & 24995985 & Полный граф с fraction = 1 (TopSorted)\\  
Complete + & 3162 & 9995082 & Полный граф с положительным весом ребер \\  
Complete - & 3162 & 9995082 & Полный граф с случайным весом ребер \\  
BalancedTree F & 8388607 & 8388608 & Сбалансирование дерево с fraction = F \\  
SquareGrid + & 2499561 & 4999122 & Квадратная решетка с положительными ребрами \\  
SquareGrid - & 2499561 & 4999122 & Квадратная решетка с случайными ребрами \\  
RandomSparse 0.5+ & 2500000 & 25000000 & \pbox{9cm}{Случайный разреженный граф с положительными ребрами и fraction = 0.5\\}  \\  
RandomSparse 0.5- & 2500000 & 25000000 & \pbox{9cm}{Случайный разреженный граф с любыми ребрами и fraction = 0.5\\}  \\  
RandomSparse 0.96+ & 2500000 & 25000000 & \pbox{9cm}{Cлучайный разреженный граф с положительными ребрами и fraction = 0.96\\} \\  
RandomDense 0.5+ & 5000 & 25000000 & \pbox{9cm}{Случайный плотный граф с положительными ребрами и fraction = 0.5\\}  \\  
RandomDense 0.5- & 5000 & 25000000 & \pbox{9cm}{Случайный плотный граф с любыми ребрами и fraction = 0.5\\}  \\  
RandomDense 0.96+ & 5000 & 25000000 & \pbox{9cm}{Случайный плотный граф с положительными ребрами и fraction = 0.96\\}  \\  
\hline

\end{tabular}

\label{bf_algo_comparison}
\end{table}
\FloatBarrier
Средние значения времени исполнения каждой версии алгоритма на описанных графах представлены в таблице \ref{graph_description}. В тех случаях, когда время исполнения алгоритма было сильно выше, чем у аналогов (значение $\infty$ в таблице), выполнение алгоритма прерывалось.
\begin{table}[H]
\centering
\caption{Результаты измерений производительности}
\begin{tabular}{l|ccc|cc|cc|ccc|ccc}  
\hline
Алгоритм & \multicolumn{3}{c}{Complete} & \multicolumn{2}{c}{BalancedTree} & \multicolumn{2}{c}{SquareGrid} & \multicolumn{3}{c}{RandomSparse} & \multicolumn{3}{c}{RandomDense}\\
& TS & + & - & 0.5 & 1 & + & - & 0.5+  & 0.5- & 0.96+ & 0.5+ & 0.5- & 0.96+\\
\hline\hline
3 & 2.43 & 4.65 & $\infty$ & 116.31 & 9.04 & 5.49 & 13.40 & $\infty$ & $\infty$ & 24.35 & $\infty$ & $\infty$ & 5.01 \\  
4 & 5.17 & 0.18 & 10.84 & 3.59 & 3.08 & 5.92 & 7.10 & 2.77 & 14.68 & 2.42 & 0.48  & 6.38  & 0.46 \\
5 & 44.63 & 0.37 & 23.55 & 0.44 & 0.31 & 4.42 & 0.58 & 0.59 & 22.59 & 0.48  & 0.60  & 10.25 & 0.71 \\
Ligra & 49.13 & 0.30 & 26.11 & 0.55 & 0.50 & 8.15 & 1.21 & 0.58 & 25.19 & 0.54  & 1.12  & 14.15 & 1.20 \\
\hline
\end{tabular}

\label{graph_description}
\end{table}

Как видно из таблицы \ref{graph_description} BFS-подобная параллельная версия оказалась в среднем быстрее существующей версий Ligra, а применимость других алгоритмов полностью согласуется с рассуждениями из предыдущего подраздела.  

\FloatBarrier
\section{Параллельные алгоритмы поиска расстояний между каждой парой вершин}

\FloatBarrier
\subsection{Анализ}


В контексте задачи поиска кратчайших расстояний между каждой парой вершин существует множество подходов. Однако заметим, что для социальных графов наш алгоритм дает асимптотически наилучшее время. Поскольку он работает за $O(VE)$, а в графе социальной сети, как видно в таблице \ref{table:algo_floyd_avg_vertex_degree}, средняя степень вершины ограничена константой около 200, то можем считать, что количество ребер в графе асимптотически равно $O(V)$. Таким образом, наш алгоритм будет работать за $O(V^2)$. Таким образом, множественные подходы, которые опираются на перемножение матриц (например, предложенный Рэймондом Сейделем \cite{SEIDEL}) и имеют в своей асимптотике некоторую степенную функцию от количества вершин, будут асимптотически хуже нашего алгоритма. Обратим внимание, однако, что наивная версия алгоритма, представленная в начале главы, будет асимптотически эквивалентна параллельному алгоритму для социальных графов. Однако, алгоритм для социальных графов имеет ряд преимуществ по сравнению с наивной версией. 


\begin{itemize}
  \item Пересчет расстояний для группы вершин выполняется быстрее за счет битовых операций. Хоть это и не сказывается на асимптотику, но на практике дает заметный выигрыш; 
  \item Все битовые операции выполняются без выделения дополнительной памяти. При этом изменяются уже созданные поля в массиве для подсчета динамики;
  \item Так как каждый из фронтиров уже построен, то нам не приходится строить следующий фронтир по предыдущему в процессе обработки;
  \item Каждый из получившихся фронтиров довольно большой, что увеличивает его способность к параллелизации;
  \item Все остальные этапы также хорошо параллелятся.
\end{itemize}

\begin{table}[H]
\centering
\caption{Среднее число друзей в социальных сетях}

\begin{tabular}{l|c}  
\hline
Социальная сеть & Средняя степень вершины\\
\hline\hline
Facebook & 190 \\  
Twitter & 208  \\
Вконтакте & 190  \\
Одноклассники & 96  \\
Slashdot & 25  \\
\hline
\multicolumn{2}{l}{\footnotesize Данные взяты из неофициальных источников}\\
\end{tabular}
\label {table:algo_floyd_avg_vertex_degree}
\end{table}

Таким образом мы имеем полные основания предполагать, что этот алгоритм на практике покажет заметно лучшие результаты по сравнению с предыдущими версиями. 

\FloatBarrier
\subsection{Тестирование}

В качестве графов для тестирования были взяты подграф социальной сети Twitter и граф научной социальной сети Slashdot (описание графов приведены в таблице \ref{table:algo_floyd_graph_description}). При этом каждое из ребер графов считалось неориентированным. \FloatBarrier
\begin{table}[H]
\centering
\caption{Описание социальных графов}

\begin{tabular}{l|c|c} 
\hline 
Граф & Вершины & Ребра\\
\hline\hline
Twitter & 81306 & 4841532\\  
Slashdot & 82168 & 877286  \\
\hline
\end{tabular}

\label {table:algo_floyd_graph_description}
\end{table}

\FloatBarrier

Для сравнения производительности были взяты два алгоритма --- наивная параллельная версия и последний описанный алгоритм. Усредненные результаты запусков приведены в таблице \ref{table:algo_floyd_comparison}.   


\FloatBarrier
\begin{table}[H]
\centering
\caption{Сравнение алгоритмов}

\begin{tabular}{l|c|c} 
\hline 
Алгоритм & Twitter & Slashdot\\
\hline\hline
Наивная параллельная версия & 427.217 & 254.567 \\  
Алгоритм для социальных графов & 191.232 & 169.393  \\
\hline
\end{tabular}

\label {table:algo_floyd_comparison}
\end{table}
\FloatBarrier

Как мы видим мы получили значительный прирост производительности в обоих случаях, что подтверждает наши ожидания относительно эффективности последнего подхода.

