%-*-coding: utf-8-*-
\chapter{Решение задачи поиска расстояний между каждой парой вершин графа}

В этой главе будет приведено решение задачи поиска расстояний между каждой парой вершин. В начале главы будет краткий обзор предметной области, после будут приведены два наивных решения для поиска пути, а после комбинацией будет приведено решение задачи для социальных неориентированных невзвешенных графов, которое будет сочетать несколько подходов и идей, изложенных в предыдущих алгоритмах. 

\FloatBarrier
\section{Обзор существующих решений}

\subsection{Алгоритм Флойда}
Одним из наиболее известных алгоритмов, который применяется для решения данной задачи является алгоритм Флойда. Этот алгоритм использует идею динамического программирования и выполняется за O(VVV). Основная идея состоит в обновлений пути между двумя текущими вершинами выбором некоторой вершины, через который может пройти потенциальный кратчайший путь. Псевдокод алгоритма приведен ниже. 

\FloatBarrier
\begin{algorithm}
\caption{Алгоритм Флойда}\label{floyd}
\begin{algorithmic}[1]
\Procedure{Floyd}{$G$}
\State $dist\gets \left\{ {   \left\{ {\infty ... \infty}\right\}  ... \left\{ {\infty ... \infty}\right\} }\right\}$
\For{$e \in G.edges $}
	\State $dist[e.from][e.to] \gets e.w$
\EndFor 
\State
\For{$i = 0$ to $|G.vertices| $}
	\For{$u = 0$ to $|G.vertices| $}
		\For{$v = 0$ to $|G.vertices| $}
			\State $dist[u][v] \gets \min(dist[u][v], dist[u][i] + dist[i][v])$
		\EndFor
	\EndFor
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\subsection{Альтернативы}
В некоторых случаях оказываются эффективны другие подходы. Например, можно для каждой вершины по отдельности запустить некоторых алгоритм поиска кратчайшего пути до всех остальных вершин. Для случая неотрицательных ребер можно применить алгоритм Дейкстры, в более общем случае может быть применен Беллман-Форд. Кроме вышеприведенных подходов также известен алгоритм Джонсона, который работает на графах без циклов отрицательного веса и находит кратчайшие расстояния за время O(VV * log(V) + VE). Все эти подходы оказываются эффективны в случае разреженных графов.

В последующих подходах в качестве основы для параллельного алгоритма будет использоваться именно идея подсчета расстояний либо для каждой вершины по отдельности, либо подсчета расстояний для групп вершин. И все нижеперечисленные алгоритмы, как и описанные выше альтернативы хорошо работает на разреженных графах.

\FloatBarrier
\section{Наивная параллельная версия}
Первая версия заключается исключительно в запуске Беллмана-Форда для каждой из вершин. При этом заметим, что так как каждый из них независим друг от друга, то можем эти запуски распараллелить между собой. Таким образом, псевдокод из себя представляет следующее


\FloatBarrier
\begin{algorithm}
\caption{Наивная параллельная версия}\label{all_pairs_par1}
\begin{algorithmic}[1]
\Procedure{AllPairsPar1}{$G$}
\State \textbf{return} $HandleVertices(G, 0, |G.vertices|)$
\EndProcedure
\State
\Procedure{HandleVertices}{$G, startVertex, endVertex$}

\If {$endVertex - startVertex < threshold$} 
	\State run parallel Bellman-Ford for every vertex 
	\State \textbf{return} $distances$	
\Else	
	\State $midV \gets (startVertex + endVertex) / 2$ 
	\State $HandleVertices(G, startV, midV)$
	\State $HandleVertices(G, midV, endV)$	
\EndIf

\EndProcedure

\end{algorithmic}
\end{algorithm}

\FloatBarrier
\section{Параллельный алгоритм для объединенного графа}
Развитием предыдущей идеи является наблюдение, что для некоторого набора вершин можем построить общий граф и запустить на нем Беллмана-Форда, что потенциально может повысить производительность за счет высокой параллельности каждого отдельно взятого Беллмана-Форда. Кроме того, это избавит нас от выбора константы для предыдущей версии, что упростит использование алгоритма для пользователя. 

Идея заключается в запуске алгоритма Беллман-Форд на графе, вершины которого описываются двумя значениями - текущей вершины в обходе и вершины, из которой этот обход начался (иными словами, вершины, из которой мы ищем кратчайшие расстояния). После построения графа будет достаточно запустить обход, при этом положив в Frontier все вершины вида (i, i). В итоге кратчайшее расстояние для вершины (i, j) будет интерпретироваться как кратчайшее расстояние от вершины i до вершины j в исходном графе. 

Однако, как будет показано позднее, такой подход на практике оказался медленнее наивной версий. Но при этом идея обработки ряда вершин одновременна легла в основе следующего алгоритма для социальных графов. 
\FloatBarrier
\section{Параллельный алгоритм для социальных графов}
В данной главе будет рассмотрен алгоритм поиска кратчайшего пути между каждой парой вершин для графов реальных социальных сетей. При этом рассмотренный граф будет невзвешенный и неориентированный. Кроме того, в этой главе будет затронута структура данных, уже ранее используемая в параллельном обходе в ширину. Будет описан ее интерфейс и принцип работы. 

\FloatBarrier
\subsection{Идея алгоритма}
В графах для социальных сетей известна одна эвристика, которая называется "Теория шести рукопожатий". В ее основе лежит тот факт, что практически любые два человека на земле знакомы не более, чем через пятерых промежуточных людей. Таким образом, выбрав некоторую случайную вершину, мы сможем добраться от нее до большинства других вершин не более, чем за 6 ребер. Воспользуемся этой эвристикой в нашем алгоритме и выберем вершину наибольшей степени в качестве базовой. И будем обрабатывать два множества различным образом - для меньшего (вершины, которые находятся на расстоянии больше шести) будем запускать параллельный обход в ширину для каждой вершины, для большого - воспользуемся методом динамического программирования для подсчета ответа. 

Но прежде, чем приступить к описанию непосредственно алгоритма опишем структуру данных, предложенную Майком Рэйни и Умутом Акаром для обработки множества ребер на нескольких ядрах - Фронтир (Frontier, англ.)

\FloatBarrier
\subsection{Структура данных Фронтир}
Структура данных подробно рассмотрена в статье Умут Акара. Здесь же приведено краткое ее описание, основные принципы работы и интерфейс. Фронтир представляет из себя некоторый набор ребер. При этом он поддерживает операций разделения множества пополам, слияния множеств, добавления ребер вершины и итерирования по ребрам. При этом  операций слияния и разбиения выполняются за время пропорциональное O(log n), добавление ребер вершины происходит за константу, а итерирование за константу для каждого ребра. Такая асимптотика достигается за счет лежащей в основе bootstrapped chunked sequence, которая представляет из себя последовательность, где каждому элементу сопоставляется его вес. И операций слияния и разбиения выполняются в соответсвии с этими весами и выполняются за O(log n). Более подробное описание bootstrapped chunked sequence приведено в статье. 

\FloatBarrier
\subsection{Работа алгоритма}
Как уже было отмечено ранее, работа алгоритма разбивается на три этапа - анализ графа и выбор базовой вершины, обработка меньшего множества и обработка большего. Разберемся с каждым этапом по отдельности.

Первый и самый простой этап состоит в выборе базовой вершины. В качестве нее будет выбрана вершина с наибольшей степенью. После этого из этой вершины будет запущен обход в ширину, который найдет все вершины, отстоящие не более, чем на K (в описанном в предыдущем пункте случае K = 6). Таким образом, все такие вершины попадают в множество, которое будет обработано на третьем этапе алгоритма. Все остальные вершины попадают в второе множество.



В качестве алгоритма для обработки второго множества запустим параллельный обход в ширину (он же Беллман-Форд) для каждой из вершин этого множества. Кроме того запустим обход для базовой вершины. Эти значения расстоянии нам помогут на третьем этапе алгоритма.

Для поиска искомых значении для вершин третьего множества воспользуемся методом динамического программирования. Но сперва обсудим основные принципы построения алгоритма и доказательство его корректности. 

Рассмотрим некоторую вершину, которая находится на расстояний D от базовой вершины (D <= K). То какие вершины для нее могут находится на расстоянии I? Это могут быть только те вершины, которые находятся на расстоянии [I-D, I+D] от базовой. Иначе бы не выполнялось свойство, что путь кратчайший. С другой стороны, если рассмотреть некоторую вершины, расстояние до которой равняется I, то для всех вершин из "большого" множества верно, что кратчайшее расстояние от них до нее варьируется в промежутке [I-K, I+K]. 

 Предположим, что мы запустили обход в ширину из всех вершин большого множества. То какие вершины могут быть в слое с номером I? Ответ вытекает из рассуждений предыдущего абзаца - только вершины, расстояние от которых до базовой варьируется в промежутке [I-K, I+K]. То есть каждая из вершин будет принимать участие в не более, чем 2K+1 слоях. То построим для каждого слоя обхода в ширину множество возможных вершин на этом слое. Это избавит нас от построения следующего фронтира по текущему. И при этом общее количество вершин во всех слоях будет пропорционально числу вершин в графе (если учитывать, что K - небольшое число, меньшее 7). 
 
 После того, как мы построили набор вершин для каждого из слоев мы можем воспользоваться структурой Фронтир для эффективного распараллеливания процесса обработки ребер, исходящих из этих вершин. Но к текущему моменту мы никак не воспользовались тем фактом, что вершины расположены близко друг к другу, и, может быть, существует способ для оптимальной обработки группы вершин. Такой подход существует и основан на идее динамического программирования и применения битовых векторов. 
 
 Будем поддерживать две динамики. Значениями в полях массива будут битовые вектора - это некоторая структура, где каждый из битов соответсвует вершине из "большого" множества. Первая из динамик mask[u][i] - это битовый вектор вершин, расстояние от которых до U равно I. Вторая из динамик calc[u][i] - набор вершин, расстояние от которых до U не более, чем I. 
 
 Рассмотрим процесс пересчета значений динамики. Для подсчета текущего значения mask воспользуемся формулой (2.1). Обратим внимание, что в битовые вектора должны поддерживать битовые логические операции. 
  
\begin{equation}
mask[v][i] = (OR (mask[u][i - 1] where \exists edge u->v)) AND (NOT calc[v][i - 1])
\end{equation}

В свою очередь calc пересчитывается согласно (2.2)
\begin{equation}
calc[v][i] = calc[v][i - 1] OR mask[v][i]
\end{equation}

Наконец, как по имеющимся данным динамики восстановить ответ? Для каждого значения mask[u][i] найдем единичные биты в маске. Установленный в единицу бит J говорит о том, что расстояние от вершины из "большого" множества с идентификатором J до вершины u равно i. Таким образом, мы сможем полностью восстановить ответ для каждой вершины. 


Итого, псевдокод алгоритма выглядит следующим образом.

\FloatBarrier
\begin{algorithm}
\caption{Параллельная версия для социальных графов}\label{all_pairs_social}
\begin{algorithmic}[1]
\State $ K \gets 6$
\State

\Procedure{AllPairsSocialPar}{$G$}
\State $dist\gets \left\{ {   \left\{ {\infty ... \infty}\right\}  ... \left\{ {\infty ... \infty}\right\} }\right\}$
\State {$ handleByBaseVertexSet, otherVertexSet \gets ConstructSets(G)$}
\State {$ AllPairsPar1(G, otherVertexSet, dist)$}
\State {$ CalculateDistancesForBigSet(G, otherVertexSet, dist)$}

\State \textbf{return} $dist$ 
\EndProcedure
\State

\Procedure{ConstructSets}{$G$}
\State {$baseVertex \gets $ vertex with max degree}
\State {run serial bfs from $baseVertex$}
\State {$handleByBaseVertexSet \gets $ vertices with dist <= K}
\State $otherVertexSet \gets G.V \setminus handleByBaseVertexSet$ 
\State \textbf{return} $ handleByBaseVertexSet, otherVertexSet$
\EndProcedure
\State


\Procedure{CalculateDistancesForBigSet}{$G, vertexSet, dist$}

\If {$smth$} 
	\State smth
\Else	
	\State smth
\EndIf

\EndProcedure

\end{algorithmic}
\end{algorithm}


\FloatBarrier
\subsection{Сравнение с наивными версиями}
бла-бла-бла.

\FloatBarrier
\section{Выводы}
Всякие разные выводы бла-бла-бла.

\FloatBarrier
