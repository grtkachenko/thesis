%-*-coding: utf-8-*-
\chapter{All-pairs shortest distance problem}



\section{Floyd-Warshall algorithm}
The most popular algorithm. $O(V^3)$

\FloatBarrier
\begin{algorithm}
\caption{Floyd-Warshall}\label{floyd}
\begin{algorithmic}[1]
\Procedure{Floyd}{$G$}
\State $dist\gets \left\{ {   \left\{ {\infty \ldots \infty}\right\}  \ldots \left\{ {\infty \ldots \infty}\right\} }\right\}$
\For{$e \in G.edges $}
	\State $dist[e.from][e.to] \gets e.w$
\EndFor 
\State
\For{$i = 0$ to $|G.vertices| $}
	\For{$u = 0$ to $|G.vertices| $}
		\For{$v = 0$ to $|G.vertices| $}
			\State $dist[u][v] \gets \min(dist[u][v], dist[u][i] + dist[i][v])$
		\EndFor
	\EndFor
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\section{First parallel version}
Idea : run parallel Bellman-Ford from every vertex. At the same time use simple scheduling for our computation

\FloatBarrier
\begin{algorithm}
\caption{First parallel version}\label{all_pairs_par1}
\begin{algorithmic}[1]
\Procedure{AllPairsPar1}{$G$}
\State \textbf{return} {\Call {HandleVertices}{$G, 0, |G.vertices|$}}
\EndProcedure
\State
\Procedure{HandleVertices}{$G, startVertex, endVertex$}

\If {$endVertex - startVertex < threshold$} 
	\State $distances \gets$ run parallel Bellman-Ford for every vertex from $startVertex$ to $endVertex$ (start - inclusively, end - exclusively)
	\State \textbf{return} $distances$	
\Else	
	\State $midV \gets (startVertex + endVertex) / 2$ 
	\State \begin{varwidth}[t]{\linewidth}fork2(\par
        \hskip\algorithmicindent {\Call {HandleVertices}{$G, startV, midV$}},\par
        \hskip\algorithmicindent {\Call {HandleVertices}{$G, midV, endV$}});
      \end{varwidth}
	
\EndIf

\EndProcedure

\end{algorithmic}
\end{algorithm}

\FloatBarrier
\section{Second parallel version}

The potential improvement of the idea above was to calculate distance for group of vertices at the same time. How does we achieve it? All we have to do is to create a large graph consisting of $V^2$ vertices. Every vertex of that graph are of the form $(i, j)$, where $i$ - current vertex id (the same as in the initial graph), $j$ - vertex from which the shortest distance is calculating. And when we're performing Bellman-Ford we have to push all the vertices of form $(i, i)$ to the first Frontier. Afterwards the process would be the same as before. Finally, when we've done with algorithm, the shortest distance $d$ to vertex $(i, j)$ means that shortest distance in the initial graph from the vertex $j$ to vertesx $i$ equals to $d$.

Unfortunately as we'll see in the following chapters this algorithms occurs to be slower than previous one. However the idea of calculating distances for the group of vertices underlies the following algorithms for social graphs. 

\FloatBarrier
\section{Third parallel version. Algorithm for social graphs}
In the following chapter I will describe algorithms to calculate all-pairs distances for social undirected unweighted graphs.   

\FloatBarrier
\subsection{Idea}
The algorithm is based on a well-known theory "Six degrees of separation" (\url{https://en.wikipedia.org/wiki/Six_degrees_of_separation}). According to that the distance beetwen any two vertices in social graph in general is quite small. So the algorithm would use this fact and calculate distances for two sets separately - for a big set of near vertex to some specific base vertex and for remaining vertices. For the big set the algorithm will use dynamic programming and for the small one it will use previous approaches. 

\FloatBarrier
\subsection{Algorithm}
The algorithm consists of three phases

\begin{enumerate}
  \item Graph analysis and base vertex selection 
  \item Small set handling
  \item Big set handling
\end{enumerate}

First phase is the easiest one. The pseudocode is below ($K$ in pseudocode is the max distance from the base vertex to be handled by it)

\FloatBarrier
\begin{algorithm}
\caption{First phase}\label{all_pairs_social1}
\begin{algorithmic}[1]
\Procedure{ConstructSets}{$G$}
\State {$baseVertex \gets $ vertex with max degree}
\State {$dist \gets $ run serial bfs from $baseVertex$}
\State $handleByBaseVertexSet \gets \emptyset$
\algrenewcommand\algorithmicfor{\textbf{parfor}} 
\For{$i = 0$ to $|G.vertices| - 1$}
\algrenewcommand\algorithmicfor{\textbf{for}}
	\If {$dist[i] \leq K$ }
		\State $handleByBaseVertexSet.add(i)$
	\EndIf
\EndFor

\State $otherVertexSet \gets G.vertices \setminus handleByBaseVertexSet$ 
\State \textbf{return} $ baseVertex, handleByBaseVertexSet, otherVertexSet$
\EndProcedure

\end{algorithmic}
\end{algorithm}

Second phase is essentially the First parallel algorithm (parallel Bellman-Ford from every vertex) but not for the whole set of vertices but for the $otherVertexSet$.

Third phase is based on the dynamic programming. Let's first write down some observations. 

Consider some vertex $i$ such that $dist[baseVertex][i] = d$. For which vertices $j$ the statement $dist[i][j] = s$ may turns to be true? It may appear only for vertices $j$ such that $s - d \leq dist[baseVertex][j] \leq s + d$. It means that if we perform a BFS and put every vertex from $handleByBaseVertexSet$ to initial set then during this BFS the vertex $j$ may appear only on layers $[t-K, t+K]$ where $t = dist[baseVertex][j] $. Therefore we may put every vertex to all the possible layers for that vertex (this amount of layers is not more than $2K+1$ what is generally very small number). And thus build a Frontier for every layer. Afterwards we'll use the classic technique to handle Frontier in parallel. But for now we haven't touched the idea of dynamic programming. Let's see how it may be useful in our case. 

 During the computation we are dealing with two dynamics. First is $mask[u][i]$ - the bitset of vertices such that the distance from them to $u$ is equals to $i$. Second is $calc[u][i]$ - the bitset of vertices such that distance from them to $u$ is less than $i$. Bitsets only have to support logical operation (or, and, not) and setting/getting the value in specific bit. For every vertex in $handleByBaseVertexSet$ there is a  bit that corresponds to the vertex (we have a bijection beetwen vertices in set and bits in bitset).  Obvious observation is that for every vertex $u$ we have to store only $2K+1$ bitsets (follows from the previous paragraph). 
 
 Let's see how we calculate dynamics. It's easy to realise these formulas (2.1 for mask and 2.2 for calc).

\FloatBarrier
\begin{equation}
mask[v][i] = \neg calc[v][i - 1] \wedge \bigvee_{\exists (u, v) \in E} mask[u][i - 1] 
\end{equation}
\FloatBarrier

\FloatBarrier
\begin{equation}
calc[v][i] = calc[v][i - 1] \vee mask[v][i]
\end{equation}
\FloatBarrier

These calculations present at the pseudocode below. Pay attention that for every vertex we have to store only $2K + 1$ bitsets. But for better understanding we do not deal with such an implementation details and access to $j$ layer of vertex $i$ just by calling $mask[i][j]$. Another notice is that for the calculation of values of layer $i$ we have to handle Frontier from the previous layer $i-1$. That's why we have $layerToCalc$ and $frontierLayer = layerToCalc - 1$ in the last loop.


\FloatBarrier
\begin{algorithm}
\caption{Dynamics calculation}\label{all_pairs_social2}
\begin{algorithmic}[1]
\State $ K \gets 6$ \Comment{Max deep to baseVertex}\ldots
\State

\Procedure{CalculateDistancesForBigSet}{$G, baseVertex, handleByBaseVertexSet$}
\State {$maxLayer \gets $ calculate max distance from baseVertex}
\State {$Frontiers \gets \left\{ {Frontier_0 \ldots Frontier_{maxLayer + K}}\right\} $} \Comment{Frontier for every BFS layer} 
\State {$VertexSets \gets \left\{ {VertexSet_0 \ldots VertexSet_{maxLayer + K}}\right\} $} \Comment{VertexSet for every BFS layer} 
\State $mask\gets \left\{ {   \left\{ {bitVector(0) \ldots bitVector(0)}\right\}  \ldots \left\{ {bitVector(0) \ldots bitVector(0)}\right\} }\right\}$ 
\State $calc\gets \left\{ {   \left\{ {bitVector(0) \ldots bitVector(0)}\right\}  \ldots \left\{ {bitVector(0) \ldots bitVector(0)}\right\} }\right\}$
\State

\For{$i = 0$ to $maxLayer + K$}	
	\For{$j = dist[baseVertex][i] - K$ to $dist[baseVertex][i] + K$}		
		\State $Frontiers[j].pushEdgesOf(i)$
		\State $VertexSets[j].addVertex(i)$
	\EndFor
\EndFor
\State

\For{$v \in handleByBaseVertexSet $}
	\State $mask[v][0].setBit(bitNum(v), 1)$ \Comment{Let's assume that we have a function $bitNum$ which by input vertex returns the index of corresponding bit in bitsets} 
\EndFor 
\State
\For{$layerToCalc = 1$ to $maxLayer + K$}
	\State $frontierLayer \gets layerToCalc - 1$ 
	\State {\Call {ProcessLayerLazy}{$G, Frontiers[frontierLayer], mask, layerToCalc$}}

	\algrenewcommand\algorithmicfor{\textbf{parfor}}
	\For{$v \in VertexSets[layerToCalc] $}
		\State {$calc[v][layerToCalc] \gets mask[v][layerToCalc] $}
		\If {$layerToCalc$ is not first layer for vertex $v$}
			\State $calc[v][layerToCalc - 1] \gets \lnot calc[v][layerToCalc - 1]$ 
			\State $mask[v][layerToCalc] \gets mask[v][layerToCalc] \land calc[v][layerToCalc - 1]$ 
			\State $calc[v][layerToCalc - 1] \gets \lnot calc[v][layerToCalc - 1]$ 
			\State $calc[v][layerToCalc] \gets calc[v][layerToCalc] \lor calc[v][layerToCalc - 1]$ 
		\EndIf

	\EndFor 
	\algrenewcommand\algorithmicfor{\textbf{for}}	
\EndFor 
\EndProcedure
\end{algorithmic}
\end{algorithm}
\FloatBarrier

Pseudocode of Frontier handling:
\begin{algorithm}
\caption{Frontier handling}\label{all_pairs_social3}
\begin{algorithmic}[1]

\Procedure{ProcessLayerLazy}{$G, Frontier, mask, layer, dists, baseVertex$}
\While {\algorithmicnot $Frontier.empty()$}
	\If {$hasIncomingQuery()$}
		\If {$Frontier.nbEdges() \leq cutoff$}
			\State $rejectQuery()$			
		\Else		
			\State $NewFrontier \gets \emptyset$
			\State $Frontier.split(NewFrontier)$
			\State \begin{varwidth}[t]{\linewidth}fork2(\par
        \hskip\algorithmicindent {\Call {ProcessLayerLazy}{$G, Frontier, mask, layer, dists, baseVertex$}},\par
        \hskip\algorithmicindent {\Call {ProcessLayerLazy}{$G, NewFrontier, mask, layer, dists, baseVertex$}});
      \end{varwidth}
		\EndIf
		
	\EndIf
	\State Frontier.iterNumber(pollingCutoff, updateFunction(mask, from, to, layer, dists, baseVertex))
\EndWhile
\EndProcedure
\State
\Procedure{UpdateFunction}{$mask, from, to, layer, dists, baseV$}
\If {HaveOnLayer(layer - 1, from, dists, baseV) \algorithmicand HaveOnLayer(layer, to, dists, baseV)} 
	
	\State $mask[to][layer] \gets mask[to][layer] \lor mask[from][layer - 1]$ \Comment Атомарно
\EndIf
\EndProcedure
\State
\Procedure{HaveOnLayer}{$layer, vertex, dists, baseV$}
\State \textbf{return} {$|layer - dists[baseV][vertex]| \leq K$}  
\EndProcedure

\end{algorithmic}
\end{algorithm}


\FloatBarrier
Finally how we can restore an answer by this dynamic? For every $mask[u][i]$ we'll find all the one-bits. The one-bit in position $j$ says that the distance from the vertex $v$ (with $bitNum(v) = j$) to vertex u is equal to $i$. That's how we can fill the answer.

The final pseudocode looks like this:

\FloatBarrier
\begin{algorithm}
\caption{Parallel algorithm for social graphs}\label{all_pairs_social}
\begin{algorithmic}[1]

\Procedure{AllPairsSocialPar}{$G$}
\State $dist\gets \left\{ {   \left\{ {\infty \ldots \infty}\right\}  \ldots \left\{ {\infty \ldots \infty}\right\} }\right\}$
\State {$ baseVertex, handleByBaseVertexSet, otherVertexSet \gets ConstructSets(G)$}
\State {\Call {AllPairsPar1}{$G, otherVertexSet, dist$}} 
\State {\Call {CalculateDistancesForBigSet}{$G, baseVertex, otherVertexSet, dist$}}

\State
\algrenewcommand\algorithmicfor{\textbf{parfor}}
\For{$v = 0$ to $|G.vertices|$}
\algrenewcommand\algorithmicfor{\textbf{for}}
	\For{$j = dist[baseVertex][i] - K$ to $dist[baseVertex][i] + K$}	
		\algrenewcommand\algorithmicfor{\textbf{parfor}}	
		\For{$u \in handleByBaseVertexSet$}
			\If {$mask[v][j].getBit(bitNum(u)) = 1$}
				\State $dist[u][v] = j$		
			\EndIf	
		\EndFor
		\algrenewcommand\algorithmicfor{\textbf{for}}
	\EndFor
\EndFor 
\State \textbf{return} $dist$ 
\EndProcedure

\end{algorithmic}
\end{algorithm}


\FloatBarrier
\subsection{Algorithms comparison}

The last algorithm doesn't have better asymptotic time, but it has several advantages.

\begin{itemize}
  \item Distance calculation performs faster than before because of bit operations (and, or, not).
  \item All the bit operations don't require any extra memory allocated. Once we allocated the memory we do all the operations right there.
  \item We don't have to do job of merging frontier during the calculations. All the frontier have already been built during the initialisation phase. 
  \item All the frontier are big enough what increase their ability to be parallelised.
  \item All the other phases are good to be parallelised as well.
\end{itemize}

To prove these advantages on practice I've implemented algorithms and tested them on Twitter subgraph with 81306 vertices and 4841532 edges (undirected; unweighted). Results are in the table \ref{table:algo_floyd_comparison} 


\FloatBarrier
\begin{table}[H]
\centering

\begin{tabular}{l|c}  
Algorithm & Twitter graph\\
\hline\hline
First parallel algorithm & 427.217 \\  
Algorithm for social graphs & 210.322  \\
\hline
\end{tabular}

\caption{Algo comparison}
\label {table:algo_floyd_comparison}
\end{table}
\FloatBarrier

As we see we have more than 2x speedup. 
 
\FloatBarrier
