%-*-coding: utf-8-*-
\chapter{Shortest path from one vertex to every other}


\FloatBarrier
\section{Classic sequential Bellman-Ford}

\FloatBarrier
\begin{algorithm}
\caption{Classic Bellman-Ford}\label{bf_classic_seq}
\begin{algorithmic}[1]
\Procedure{ClassicBellmanFord}{$G,start$}
\State {$dist \gets \left\{ {\infty ... \infty}\right\}$}
\State {$dist[start] \gets 0$}
 
\For{$i = 0$ to $|G.vertices| - 1 $}
	\For{$e \in G.edges $}
		\State $dist[e.to] \gets \min(dist[e.to], dist[e.from] + e.w)$
	\EndFor
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\section{BFS-like sequential Bellman-Ford}

\FloatBarrier
\begin{algorithm}
\caption{BFS-like BellmanFord}\label{bf_bfs_seq}
\begin{algorithmic}[1]
\Procedure{BFSBellmanFord}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
\State $CurrentVertexSet \gets \left\{ {start}\right\}$\Comment{Set of vertices the distance to which has just been updated} 
\State $NextVertexSet \gets \emptyset$ 
\State {$step \gets 0$ }
\While {$step < |G.vertices|$ \algorithmicand \algorithmicnot $ CurrentVertexSet.empty()$}
	\State $step \gets step + 1$
	\State $NextVertexSet.clear()$
	
	\For{$v \in CurrentVertexSet$}
		\For{$e \in G.edgesFrom[v] $} \Comment{Outgoing edges of current vertex} 
			\If {$dist[e.to] < dist[e.from] + e.w$} 
				\State $dist[e.to] \gets dist[e.from] + e.w$
				\State $NextVertexSet.insert(e.to)$								
			\EndIf
		\EndFor
	\EndFor
	
	\State $CurrentVertexSet \gets NextVertexSet$	
\EndWhile
\State \textbf{return} $dist$

\EndProcedure
\end{algorithmic}
\end{algorithm}


\FloatBarrier
\subsection{Parallel Bellman-Ford by edges of current vertex}
Idea : use parallel min reduce for incoming edges of current vertex   


\FloatBarrier
\begin{algorithm}
\caption{Parallel Bellman-Ford by edges of current vertex}\label{bf_classic_par1}
\begin{algorithmic}[1]
\Procedure{BellmanFordPar1}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
 
\For{$i = 0$ to $|G.vertices| - 1 $}
	\State {$changed \gets $ \algorithmicfalse}
	\For{$v \in G.vertices $}
		\algrenewcommand\algorithmicfor{\textbf{parfor}}
		\State {$minDist \gets $ min reduce by G.inEdges[v]} 
		
		\If {$dist[v] > minDist$} 
			\State $dist[v] \gets minDist$
			\State {$changed \gets $ \algorithmictrue}						
		\EndIf
		\algrenewcommand\algorithmicfor{\textbf{for}}

	\EndFor
	\If {\algorithmicnot $changed$} 
		\State $break$
	\EndIf
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\subsection{Parallel Bellman-Ford by all edges using prefixsum}

Idea : use precalculated prefixsum to divide current vertex set for 2 sets, which will be handled by different threads


\FloatBarrier
\begin{algorithm}
\caption{Parallel Bellman-Ford by all edges using prefixsum}\label{bf_classic_par2}
\begin{algorithmic}[1]
\Procedure{BellmanFordPar2}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
\State {$prefsum \gets $ prefix sum by vertices incoming degree} 
\State {$planMap \gets $ \Call {BuildPlan}{$prefsum$, 0, |$G.vertices$|}} 

\For{$i = 0$ to $|G.vertices| $}	
	\If {\algorithmicnot \Call {ProcessLayer}{$G, planMap, prefsum, 0, |G.vertices|$}} 
		\State \textbf{break}
	\EndIf
		
\EndFor
\State \textbf{return} $dist$
\EndProcedure

\State 
\Procedure{BuildPlan}{$prefsum, startV, endV$}  \Comment{This function returns a structure which tells us the middle of the segments (by index of start and end vertex)}
\State {$resultMap \gets $ empty map}
\State $edgesNumber \gets prefsum[endV] - prefsum[startV]$
\If {$edgesNumber < threshold$} 
	\State $midV \gets $ binary search by edges number
	\State $resultMap[startV][endV] \gets midV$ 
	\State {$resultMap.addAll($ \Call {BuildPlan}{$prefsum, startV, midV$})} 
	\State {$resultMap.addAll($ \Call {BuildPlan}{$prefsum, midV, endV$})} 
\EndIf

\State \textbf{return} $resultMap$
\EndProcedure

\State 
\Procedure{ProcessLayer}{$G, planMap, prefsum, startV, endV$}  
\State $edgesNumber \gets prefsum[endV] - prefsum[startV]$
\If {$edgesNumber < threshold$} 
	\State process vertices sequentally 	
\Else	
	\State $midV \gets planMap[startV][endV]$ 
	\State {\Call {ProcessLayer}{$G, planMap, prefsum, startV, midV$}}
	\State {\Call {ProcessLayer}{$G, planMap, prefsum, midV, endV$}}
\EndIf

\EndProcedure

\end{algorithmic}
\end{algorithm}

\FloatBarrier
\subsection{Parallel BFS-like Bellman-Ford}
Idea : use your PBFS to handle vertex distances

\FloatBarrier
\begin{algorithm}
\caption{Parallel BFS-like Bellman-Ford}\label{bf_bfs_par}
\begin{algorithmic}[1]
\Procedure{BellmanFordPar3}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
\State {$Frontier \gets \left\{ {G.edgesFrom(start)}\right\}$}
\For{$i = 0$ to $|G.vertices| $}	
	\State {$Frontier \gets $  {\Call {HandleFrontier}{$Frontier$}}} \Comment{relax edges from Frontier and build a new one} 
	
	\If { $Frontier.empty()$} 
		\State $break$						
	\EndIf
		
		
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\State
\Procedure{HandleFrontier}{$Frontier$}
\State recursively divide current frontier, atomically relax edges in frontier and building a new one

\State \textbf{return} $NewFrontier$
\EndProcedure

\end{algorithmic}
\end{algorithm}


\FloatBarrier
\subsection{Algo comparison}
At the first sight it may seems that Algorithm 3 has only disadvantages. The main problem is that it has bad parallelisation ability compared to other two algorithms. But sometimes it works better even on 40-core machine because of one useful property. Let's consider a graph where all the edges have the from $i \rightarrow j$ where $i < j$. Once the iteration number $I$ has passed all the vertices till $I$ have correct target distance. It' easy to prove using mathematic induction. So it means that we have to perform only 2(!!!) loops in that case. One for calculating distance and one for understanding that nothing will change anymore. And let's assume that we have a dense graph. In that circumstances Algorithm 4 will suffer from great parallelism (the number of iterations of the main loop will increase significantly) and Algorithm 5 will have to handle the large set of vertices (because graph is dense) during the iterations. 

But anyway it's easy to see that in the most cases Algorithm 4 and Algorithm 5 will beat Algorithm 3. Let's compare them. As I said before Algorithm 5 will be not good enough when we're considering dense graphs, because of big size of queue. So the main recommendation of when to use these approaches is to realise if the graph is dense or sparse. In the first case you have to use Algorithm 4, otherwise Algorithm 5.


\FloatBarrier
\subsection{Testing}

Now we'll prove our assumptions on practice. I've implemented all the algorithms and compared them. Description of input graphs is presented in the Table 1.1. The results are presented in the Table 1.2
\FloatBarrier

\begin{table}[H]
\centering

\begin{tabular}{c|c|c}  
Name & Vertices & Edges\\
\hline\hline
CompleteTS sign(-) & 7071 & 24995985 \\  
Complete sign & 3162 & 9995082  \\  
BalancedTree fraction & 8388607 & 8388608 \\  
SquareGrid sign & 2499561 & 4999122  \\  
RandomSparse fraction(0.5) sign & 2500000 & 25000000  \\  
RandomSparse fraction(0.96) sign(+) & 2500000 & 25000000  \\  
RandomDense fraction(0.5) sign & 5000 & 25000000  \\  
RandomDense fraction(0.96) sign(+) & 5000 & 25000000  \\  
\hline
\multicolumn{3}{l}{\footnotesize \textit{sign} - sign of weights on edges }\\
\multicolumn{3}{l}{\footnotesize \textit{fraction} - fraction of lexicographically sorted edges (edges of type X -> X+i) }\\
\multicolumn{3}{l}{\footnotesize \textit{TS} - exists only Lexicographically Sorted edges (fraction = 1) }\\
\multicolumn{3}{l}{\footnotesize }\\
\multicolumn{3}{l}{\footnotesize  expression "\textit{RandomDense fraction(0.5) sign}" means Random Dense }\\
\multicolumn{3}{l}{\footnotesize 	graph with specified fraction and any sign of weights}\\
\end{tabular}

\caption{Input graph description}
\label{bf_algo_comparison}
\end{table}
\FloatBarrier

\begin{table}[H]
\centering

\begin{tabular}{l|ccc|cc|cc|ccc|ccc}  
Algo â„–& \multicolumn{3}{c}{Complete} & \multicolumn{2}{c}{BalancedTree} & \multicolumn{2}{c}{SquareGrid} & \multicolumn{3}{c}{RandomSparse} & \multicolumn{3}{c}{RandomDense}\\
& TS- & + & - & 0.5 & 1 & + & +- & 0.5+  & 0.5- & 0.96+ & 0.5+ & 0.5- & 0.96+\\
\hline\hline
3 & 2.43 & 4.65 & nc & 116.31 & 9.04 & 5.49 & 13.40 & nc & nc & 24.35 & nc & nc & 5.01 \\  
4 & 5.17 & 0.18 & 10.84 & 3.59 & 3.08 & 5.92 & 7.10 & 2.77 & 14.68 & 2.42 & 0.48  & 6.38  & 0.46 \\
5 & 44.63 & 0.37 & 23.55 & 0.44 & 0.31 & 4.42 & 0.58 & 0.98 & 22.59 & 0.76  & 0.60  & 10.25 & 0.71 \\
\hline
\end{tabular}

\caption{Bellman-Ford algorithms comparison}
\label{graph_description}
\end{table}

\FloatBarrier
\section{Conclusion}

You can easily find out from tables that our assumptions were correct. Algorithm 3 works good for dense graph with very high fraction (almost 1), Algorithm 4 is good for dense graphs and for graphs with negative edges, Algorithm 5 is good for sparse graph with positive edges. 

\FloatBarrier
