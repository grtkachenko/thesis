%-*-coding: utf-8-*-
\chapter{Поиск кратчайших расстояний в графах}
\label{chapSVD}

В данной главе описаны алгоритмы по решению классических задач на графах --- поиску кратчайших расстояний от одной вершины до всех остальных и между каждой парой вершин. В первом разделе главы представлен обзор существующих решений задачи поиска расстояний от фиксированной вершины. Во втором разделе предложены алгоритмы поиска расстояний между каждой парой вершин. В третьем разделе описана постановка задачи исследования.

\FloatBarrier
\section{Методы решения задачи поиска кратчайшего расстояния от фиксированной вершины}

В данном разделе представлен краткий обзор предметной области --- существующие последовательные и параллельные модификации алгоритма Беллмана-Форда.

\FloatBarrier
\subsection{Алгоритм Беллмана-Форда}

В контексте решения задачи поиска кратчайших расстояний от одной вершины до всех остальных существует два наиболее распространенных решения --- алгоритм Дейкстры и алгоритм Беллмана-Форда. Существует множество модификации алгоритма Дейкстры, которые в зависимости от используемой структуры данных работают $O(V^2+E)$, $O(E \log V)$ или $O(V \log V+E)$.\footnote{V --- количество вершин}\footnote{E --- количество ребер} Однако такие алгоритмы не работают на графах с отрицательным весом ребер. Классический алгоритм Беллмана-Форда работает на графах с произвольным весом ребер. Важным его недостатком является асимптотика --- $O(VE)$. Однако за счет возможности ранней остановки алгоритма и различных оптимизаций на практике на некоторых графовых структурах он может давать результаты, лучшие чем алгоритм Дейкстры. Именно по этой причине основной упор в работе делается на этот алгоритм. Также известны специализированные алгоритмы, такие как алгоритм A* и D*, которые оперируют большими специализированными графами и используют ряд эвристик для поиска расстояний. При этом в контексте наших исследований они затронуты не будут, а сосредоточимся мы именно на алгоритме Беллмана-Форда и его модификациях.   

В основе алгоритма лежит идея динамического программирования. После $k$ итерации алгоритма утверждается, что будут корректно посчитаны и обработаны пути длиной не более $k$. И после $V$ итерации расстояние до каждой из вершин посчитано корректно. Ниже приведен каноничный псевдокод алгоритма. 

\FloatBarrier
\begin{algorithm}
\caption{Классический алгоритм Беллмана-Форда}\label{bf_classic_seq}
\begin{algorithmic}[1]
\Procedure{ClassicBellmanFord}{$G,start$}
\State {$dist \gets \left\{ {\infty ... \infty}\right\}$}
\State {$dist[start] \gets 0$}
 
\For{$i = 0$ to $|G.vertices| - 1 $}
	\For{$e \in G.edges $}
		\State $dist[e.to] \gets \min(dist[e.to], dist[e.from] + e.w)$
	\EndFor
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
Кроме того, существует интересная модификация алгоритма, которая поддерживает на каждой итерации набор вершин, расстояние до которых изменилось на предыдущем шаге алгоритма. Из очевидных соображений мы имеем право рассматривать только эти и никакие другие вершины. Этот алгоритм на практике зачастую работает заметно быстрее, чем классическая версия. Однако в некоторых случаях он оказывается медленнее. Об этих особенностях подхода подробно описано в главе, посвященной сравнению алгоритмов. Будем называть эту версию BFS-подобный Беллман-Форд (алгоритм \ref{bf_bfs_seq}). 

\FloatBarrier
\begin{algorithm}
\caption{BFS-подобный Беллман-Форд}\label{bf_bfs_seq}
\begin{algorithmic}[1]
\Procedure{BFSBellmanFord}{$G,start$}
\State $dist\gets \left\{ {\infty ... \infty}\right\}$
\State $dist[start] \gets 0$
\State $CurrentVertexSet \gets \left\{ {start}\right\}$\Comment{Набор вершин, расстояние до которых обновилось} 
\State $NextVertexSet \gets \emptyset$ 
\State {$step \gets 0$ }
\While {$step < |G.vertices|$ \algorithmicand \algorithmicnot $ CurrentVertexSet.empty()$}
	\State $step \gets step + 1$
	\State $NextVertexSet.clear()$
	
	\For{$v \in CurrentVertexSet$}
		\For{$e \in G.edgesFrom[v] $} \Comment{Исходящие ребра из текущей вершины} 
			\If {$dist[e.to] > dist[e.from] + e.w$} 
				\State $dist[e.to] \gets dist[e.from] + e.w$
				\State $NextVertexSet.insert(e.to)$								
			\EndIf
		\EndFor
	\EndFor
	
	\State $CurrentVertexSet \gets NextVertexSet$	
\EndWhile
\State \textbf{return} $dist$

\EndProcedure
\end{algorithmic}
\end{algorithm}


\FloatBarrier
\subsection{Параллельные модификации Беллмана-Форда}

Большинство параллельных алгоритмов опираются на классическую реализацию алгоритма Беллмана-Форда и применяют различные методы для параллелизации внутреннго цикла релаксации ребер \cite{COHEN}\cite{GAURAV}. Кроме того, известны статьи, в которых описаны методы параллелизации BFS-подобной версии Беллмана-Форда \cite{LIGRA}. Мною предложенная BFS-подобная версия показала лучший результат, нежели существующий аналог. При этом для параллельных модификации классической версии были обозначены области применения и их преимущества и недостатки относительно BFS-подобной версии. Однако, в силу специфичности многих существующих решений и их зависимости от библиотек, на которых они основаны, мною предложенные параллельные версии классического Беллмана-Форда сравниваться с аналогами не будут. 


\FloatBarrier
\section{Методы решения задачи поиска кратчайших расстояний между каждой парой вершин}
В данном разделе представлен обзор существующих решений задачи поиска кратчайших расстояний между каждой парой вершин --- алгоритм Флойда, а также его альтернативы для разреженных графов.
\subsection{Алгоритм Флойда}
Одним из наиболее известных алгоритмов, который применяется для решения данной задачи является алгоритм Флойда \cite{CORMEN}. Этот алгоритм использует подход динамического программирования и выполняется за $O(V^3)$. Основная идея состоит в обновлений пути между двумя текущими вершинами выбором некоторой вершины, через которую может пройти потенциальный кратчайший путь. Псевдокод алгоритма приведен ниже. 

\FloatBarrier
\begin{algorithm}
\caption{Алгоритм Флойда}\label{floyd}
\begin{algorithmic}[1]
\Procedure{Floyd}{$G$}
\State $dist\gets \left\{ {   \left\{ {\infty \ldots \infty}\right\}  \ldots \left\{ {\infty \ldots \infty}\right\} }\right\}$
\For{$e \in G.edges $}
	\State $dist[e.from][e.to] \gets e.w$
\EndFor 
\State
\For{$i = 0$ to $|G.vertices| $}
	\For{$u = 0$ to $|G.vertices| $}
		\For{$v = 0$ to $|G.vertices| $}
			\State $dist[u][v] \gets \min(dist[u][v], dist[u][i] + dist[i][v])$
		\EndFor
	\EndFor
\EndFor
\State \textbf{return} $dist$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\subsection{Альтернативы}
В некоторых случаях оказываются эффективны другие подходы. Например, можно для каждой вершины по отдельности запустить некоторый алгоритм поиска кратчайшего пути до всех остальных вершин. Для случая неотрицательных ребер можно применить алгоритм Дейкстры, в более общем случае может быть применен Беллман-Форд. Кроме вышеприведенных подходов также известен алгоритм Джонсона, который работает на графах без циклов отрицательного веса и находит кратчайшие расстояния за время $O(V^2 \log(V) + VE)$. Все эти алгоритмы оказываются эффективны в случае разреженных графов.

В последующих подходах в качестве основы для параллельного алгоритма будет использоваться именно идея подсчета расстояний либо для каждой вершины по отдельности, либо подсчета расстояний для групп вершин одновременно. И все рассматриваемые в работе алгоритмы, как и описанные выше альтернативы, хорошо работают на разреженных графах.

\FloatBarrier
\section{Постановка задачи}

В ходе работы предстояло разработать эффективные и практичные параллельные алгоритмы для решения обеих задачи. При этом, для каждого из подходов необходимо было выяснить область применения, сравнить их друг с другом, а также реализовать на основе библиотеки для параллельных вычислений и, тем самым, проверить все гипотезы на практике на ряде графовых структур.   
